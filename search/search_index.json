{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Ecuaci\u00f3n de Calor en Dos Dimensiones","text":""},{"location":"#bienvenido","title":"Bienvenido","text":"<p>Este proyecto presenta una soluci\u00f3n num\u00e9rica completa para la ecuaci\u00f3n de calor en dos dimensiones, implementando m\u00e9todos de diferencias finitas con el esquema de Euler Impl\u00edcito (Backward Euler).</p>"},{"location":"#vision-general-del-proyecto","title":"Visi\u00f3n General del Proyecto","text":"<p>La ecuaci\u00f3n de calor describe c\u00f3mo se distribuye la temperatura en una regi\u00f3n a lo largo del tiempo. En este proyecto, resolvemos:</p> \\[ \\frac{\\partial u}{\\partial t} = c^2 \\left[\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\\right] \\] <p>donde:</p> <ul> <li>\\(u = u(x, y, t)\\): temperatura en el punto \\((x, y)\\) en el tiempo \\(t\\)</li> <li>\\(c\\): coeficiente de difusi\u00f3n t\u00e9rmica</li> <li>\\(x \\in [0, a]\\), \\(y \\in [0, b]\\): regi\u00f3n espacial bidimensional</li> </ul>"},{"location":"#caracteristicas-del-proyecto","title":"Caracter\u00edsticas del proyecto","text":"<ul> <li>Implementaci\u00f3n en Python</li> <li>Animaci\u00f3n de la evoluci\u00f3n temporal para diversas condiciones iniciales y de fronter</li> <li>Implementaci\u00f3n en C++</li> <li>Aceleraci\u00f3n de la implementaci\u00f3n mediante paralelismo de memoria compartida</li> </ul>"},{"location":"referencias/","title":"Referencias","text":"<p>Esta secci\u00f3n proporciona referencias bibliogr\u00e1ficas y recursos adicionales sobre la ecuaci\u00f3n de calor, m\u00e9todos num\u00e9ricos y an\u00e1lisis.</p>"},{"location":"referencias/#libros-de-texto","title":"Libros de Texto","text":""},{"location":"referencias/#ecuaciones-diferenciales-parciales","title":"Ecuaciones Diferenciales Parciales","text":"<ol> <li>Evans, L. C. (2010). Partial Differential Equations (2nd ed.). American Mathematical Society.</li> <li> <p>Tratamiento riguroso de EDPs, incluyendo teor\u00eda de la ecuaci\u00f3n de calor</p> </li> <li> <p>Strauss, W. A. (2007). Partial Differential Equations: An Introduction (2nd ed.). Wiley.</p> </li> <li> <p>Introducci\u00f3n accesible con enfoque en aplicaciones f\u00edsicas</p> </li> <li> <p>Haberman, R. (2012). Applied Partial Differential Equations with Fourier Series and Boundary Value Problems (5th ed.). Pearson.</p> </li> <li>Excelente para m\u00e9todos de separaci\u00f3n de variables y series de Fourier</li> </ol>"},{"location":"referencias/#metodos-numericos","title":"M\u00e9todos Num\u00e9ricos","text":"<ol> <li>LeVeque, R. J. (2007). Finite Difference Methods for Ordinary and Partial Differential Equations. SIAM.</li> <li>Referencia esencial para m\u00e9todos de diferencias finitas</li> <li> <p>Cubre an\u00e1lisis de estabilidad y convergencia</p> </li> <li> <p>Iserles, A. (2008). A First Course in the Numerical Analysis of Differential Equations (2nd ed.). Cambridge University Press.</p> </li> <li> <p>An\u00e1lisis matem\u00e1tico riguroso de esquemas num\u00e9ricos</p> </li> <li> <p>Morton, K. W., &amp; Mayers, D. F. (2005). Numerical Solution of Partial Differential Equations (2nd ed.). Cambridge University Press.</p> </li> <li>Cubre Crank-Nicolson y otros esquemas impl\u00edcitos</li> </ol>"},{"location":"referencias/#articulos-cientificos","title":"Art\u00edculos Cient\u00edficos","text":""},{"location":"referencias/#metodo-de-euler-implicito","title":"M\u00e9todo de Euler Impl\u00edcito","text":"<ol> <li>Butcher, J. C. (2008). Numerical Methods for Ordinary Differential Equations (2nd ed.). Wiley.</li> <li> <p>An\u00e1lisis de m\u00e9todos impl\u00edcitos incluyendo Backward Euler</p> </li> <li> <p>Thomas, J. W. (1995). Numerical Partial Differential Equations: Finite Difference Methods. Springer.</p> </li> <li>An\u00e1lisis detallado de estabilidad de esquemas impl\u00edcitos</li> </ol>"},{"location":"referencias/#metodo-de-crank-nicolson-referencia","title":"M\u00e9todo de Crank-Nicolson (Referencia)","text":"<ol> <li>Crank, J., &amp; Nicolson, P. (1947). \"A practical method for numerical evaluation of solutions of partial differential equations of the heat-conduction type.\" Proceedings of the Cambridge Philosophical Society, 43(1), 50-67.</li> <li> <p>Art\u00edculo original del m\u00e9todo</p> </li> <li> <p>Thomas, J. W. (1995). Numerical Partial Differential Equations: Finite Difference Methods. Springer.</p> </li> <li>An\u00e1lisis detallado de estabilidad del esquema Crank-Nicolson</li> </ol>"},{"location":"referencias/#condiciones-de-frontera","title":"Condiciones de Frontera","text":"<ol> <li>Gustafsson, B., Kreiss, H. O., &amp; Oliger, J. (1995). Time Dependent Problems and Difference Methods. Wiley.</li> <li> <p>Tratamiento riguroso de condiciones de frontera en esquemas num\u00e9ricos</p> </li> <li> <p>Strikwerda, J. C. (2004). Finite Difference Schemes and Partial Differential Equations (2nd ed.). SIAM.</p> <ul> <li>Implementaci\u00f3n pr\u00e1ctica de condiciones de Neumann</li> </ul> </li> </ol>"},{"location":"referencias/#recursos-en-linea","title":"Recursos en L\u00ednea","text":""},{"location":"referencias/#tutoriales-y-documentacion","title":"Tutoriales y Documentaci\u00f3n","text":"<ol> <li> <p>SciPy Sparse Linear Algebra</p> <ul> <li>URL: https://docs.scipy.org/doc/scipy/reference/sparse.linalg.html</li> <li>Documentaci\u00f3n oficial de solvers para sistemas dispersos</li> </ul> </li> <li> <p>NumPy User Guide</p> <ul> <li>URL: https://numpy.org/doc/stable/user/</li> <li>Gu\u00eda completa de operaciones matriciales</li> </ul> </li> <li> <p>Matplotlib Gallery</p> <ul> <li>URL: https://matplotlib.org/stable/gallery/index.html</li> <li>Ejemplos de visualizaci\u00f3n cient\u00edfica</li> </ul> </li> </ol>"},{"location":"referencias/#cursos-y-notas-de-clase","title":"Cursos y Notas de Clase","text":"<ol> <li> <p>MIT OpenCourseWare: Numerical Methods for PDEs</p> <ul> <li>URL: https://ocw.mit.edu/courses/mathematics/</li> <li>Material de curso 18.336: Numerical Methods for PDEs</li> </ul> </li> <li> <p>Stanford CS 205A: Mathematical Methods for Robotics, Vision, and Graphics</p> <ul> <li>URL: https://graphics.stanford.edu/courses/cs205a/</li> <li>Incluye m\u00e9todos num\u00e9ricos para ecuaciones de calor</li> </ul> </li> </ol>"},{"location":"referencias/#aplicaciones-y-contexto-fisico","title":"Aplicaciones y Contexto F\u00edsico","text":""},{"location":"referencias/#transferencia-de-calor","title":"Transferencia de Calor","text":"<ol> <li> <p>Incropera, F. P., et al. (2011). Fundamentals of Heat and Mass Transfer (7th ed.). Wiley.</p> <ul> <li>Contexto f\u00edsico y aplicaciones ingenieriles</li> </ul> </li> <li> <p>Cengel, Y. A., &amp; Ghajar, A. J. (2014). Heat and Mass Transfer: Fundamentals and Applications (5th ed.). McGraw-Hill.</p> <ul> <li>Aplicaciones pr\u00e1cticas en ingenier\u00eda</li> </ul> </li> </ol>"},{"location":"referencias/#fisica-matematica","title":"F\u00edsica Matem\u00e1tica","text":"<ol> <li> <p>Arfken, G. B., Weber, H. J., &amp; Harris, F. E. (2013). Mathematical Methods for Physicists (7th ed.). Academic Press.</p> <ul> <li>M\u00e9todos matem\u00e1ticos para resolver EDPs en f\u00edsica</li> </ul> </li> <li> <p>Boas, M. L. (2006). Mathematical Methods in the Physical Sciences (3rd ed.). Wiley.</p> <ul> <li>Introducci\u00f3n accesible a m\u00e9todos de separaci\u00f3n de variables</li> </ul> </li> </ol>"},{"location":"referencias/#software-y-bibliotecas","title":"Software y Bibliotecas","text":""},{"location":"referencias/#python","title":"Python","text":"<ol> <li> <p>Harris, C. R., et al. (2020). \"Array programming with NumPy.\" Nature, 585(7825), 357-362.</p> <ul> <li>Paper sobre NumPy</li> </ul> </li> <li> <p>Virtanen, P., et al. (2020). \"SciPy 1.0: fundamental algorithms for scientific computing in Python.\" Nature Methods, 17(3), 261-272.</p> <ul> <li>Paper sobre SciPy</li> </ul> </li> </ol>"},{"location":"referencias/#bibliotecas-alternativas","title":"Bibliotecas Alternativas","text":"<ol> <li> <p>Firedrake Project</p> <ul> <li>URL: https://www.firedrakeproject.org/</li> <li>Framework de elementos finitos en Python</li> </ul> </li> <li> <p>FEniCS Project</p> <ul> <li>URL: https://fenicsproject.org/</li> <li>Otro framework popular para resolver EDPs</li> </ul> </li> </ol>"},{"location":"referencias/#topicos-avanzados","title":"T\u00f3picos Avanzados","text":""},{"location":"referencias/#analisis-de-error","title":"An\u00e1lisis de Error","text":"<ol> <li> <p>Quarteroni, A., Sacco, R., &amp; Saleri, F. (2007). Numerical Mathematics (2nd ed.). Springer.</p> <ul> <li>An\u00e1lisis riguroso de error y convergencia</li> </ul> </li> <li> <p>S\u00fcli, E., &amp; Mayers, D. F. (2003). An Introduction to Numerical Analysis. Cambridge University Press.</p> <ul> <li>Teor\u00eda de aproximaci\u00f3n num\u00e9rica</li> </ul> </li> </ol>"},{"location":"referencias/#metodos-adaptativos","title":"M\u00e9todos Adaptativos","text":"<ol> <li> <p>Verf\u00fcrth, R. (2013). A Posteriori Error Estimation Techniques for Finite Element Methods. Oxford University Press.</p> <ul> <li>T\u00e9cnicas de refinamiento adaptativo de malla</li> </ul> </li> <li> <p>Babu\u0161ka, I., &amp; Rheinboldt, W. C. (1978). \"A-posteriori error estimates for the finite element method.\" International Journal for Numerical Methods in Engineering, 12(10), 1597-1615.</p> <ul> <li>Art\u00edculo fundamental sobre estimaci\u00f3n de error</li> </ul> </li> </ol>"},{"location":"referencias/#paralelizacion","title":"Paralelizaci\u00f3n","text":"<ol> <li> <p>Gropp, W., Lusk, E., &amp; Skjellum, A. (1999). Using MPI: Portable Parallel Programming with the Message-Passing Interface (2nd ed.). MIT Press.</p> <ul> <li>Para implementaciones paralelas con MPI</li> </ul> </li> <li> <p>Chapman, B., Jost, G., &amp; Van Der Pas, R. (2007). Using OpenMP: Portable Shared Memory Parallel Programming. MIT Press.</p> <ul> <li>Paralelizaci\u00f3n con OpenMP</li> </ul> </li> </ol>"},{"location":"referencias/#validacion-y-verificacion","title":"Validaci\u00f3n y Verificaci\u00f3n","text":""},{"location":"referencias/#soluciones-analiticas","title":"Soluciones Anal\u00edticas","text":"<ol> <li> <p>Carslaw, H. S., &amp; Jaeger, J. C. (1959). Conduction of Heat in Solids (2nd ed.). Oxford University Press.</p> <ul> <li>Colecci\u00f3n extensa de soluciones anal\u00edticas</li> </ul> </li> <li> <p>\u00d6z\u0131\u015f\u0131k, M. N. (1993). Heat Conduction (2nd ed.). Wiley.</p> <ul> <li>Soluciones exactas para diversos casos</li> </ul> </li> </ol>"},{"location":"referencias/#benchmarks","title":"Benchmarks","text":"<ol> <li>NIST Digital Library of Mathematical Functions<ul> <li>URL: https://dlmf.nist.gov/</li> <li>Funciones especiales y soluciones est\u00e1ndar</li> </ul> </li> </ol>"},{"location":"referencias/#repositorios-de-codigo","title":"Repositorios de C\u00f3digo","text":""},{"location":"referencias/#implementaciones-de-referencia","title":"Implementaciones de Referencia","text":"<ol> <li> <p>SciPy Cookbook - Solving PDEs</p> <ul> <li>URL: https://scipy-cookbook.readthedocs.io/</li> <li>Ejemplos pr\u00e1cticos de implementaci\u00f3n</li> </ul> </li> <li> <p>GitHub: Numerical Methods</p> <ul> <li>URL: https://github.com/topics/numerical-methods</li> <li>Colecci\u00f3n de implementaciones open-source</li> </ul> </li> </ol>"},{"location":"referencias/#estandares-y-mejores-practicas","title":"Est\u00e1ndares y Mejores Pr\u00e1cticas","text":""},{"location":"referencias/#programacion-cientifica","title":"Programaci\u00f3n Cient\u00edfica","text":"<ol> <li> <p>Wilson, G., et al. (2014). \"Best practices for scientific computing.\" PLOS Biology, 12(1), e1001745.</p> <ul> <li>Gu\u00eda de buenas pr\u00e1cticas en c\u00f3mputo cient\u00edfico</li> </ul> </li> <li> <p>Wilson, G., et al. (2017). \"Good enough practices in scientific computing.\" PLOS Computational Biology, 13(6), e1005510.</p> <ul> <li>Pr\u00e1cticas recomendadas para proyectos cient\u00edficos</li> </ul> </li> </ol>"},{"location":"referencias/#software-de-visualizacion","title":"Software de Visualizaci\u00f3n","text":""},{"location":"referencias/#herramientas-avanzadas","title":"Herramientas Avanzadas","text":"<ol> <li> <p>ParaView</p> <ul> <li>URL: https://www.paraview.org/</li> <li>Visualizaci\u00f3n 3D avanzada para datos cient\u00edficos</li> </ul> </li> <li> <p>VisIt</p> <ul> <li>URL: https://visit-dav.github.io/visit-website/</li> <li>Herramienta de visualizaci\u00f3n para simulaciones a gran escala</li> </ul> </li> </ol>"},{"location":"referencias/#recursos-educativos","title":"Recursos Educativos","text":""},{"location":"referencias/#videos-y-cursos-online","title":"Videos y Cursos Online","text":"<ol> <li> <p>3Blue1Brown: Differential Equations</p> <ul> <li>URL: https://www.youtube.com/c/3blue1brown</li> <li>Visualizaciones intuitivas de conceptos matem\u00e1ticos</li> </ul> </li> <li> <p>MIT 18.086: Mathematical Methods for Engineers II</p> <ul> <li>URL: https://ocw.mit.edu/courses/18-086-mathematical-methods-for-engineers-ii-spring-2006/</li> <li>Video lectures sobre EDPs y m\u00e9todos num\u00e9ricos</li> </ul> </li> </ol>"},{"location":"referencias/#aplicaciones-especificas","title":"Aplicaciones Espec\u00edficas","text":""},{"location":"referencias/#ciencia-de-materiales","title":"Ciencia de Materiales","text":"<ol> <li>Balluffi, R. W., Allen, S. M., &amp; Carter, W. C. (2005). Kinetics of Materials. Wiley.<ul> <li>Difusi\u00f3n en materiales</li> </ul> </li> </ol>"},{"location":"referencias/#biologia","title":"Biolog\u00eda","text":"<ol> <li>Murray, J. D. (2002). Mathematical Biology I: An Introduction (3rd ed.). Springer.<ul> <li>Ecuaciones de difusi\u00f3n en sistemas biol\u00f3gicos</li> </ul> </li> </ol>"},{"location":"referencias/#finanzas","title":"Finanzas","text":"<ol> <li>Wilmott, P., Howison, S., &amp; Dewynne, J. (1995). The Mathematics of Financial Derivatives. Cambridge University Press.<ul> <li>Ecuaci\u00f3n de calor en modelos financieros (Black-Scholes)</li> </ul> </li> </ol>"},{"location":"referencias/#conferencias-y-journals","title":"Conferencias y Journals","text":""},{"location":"referencias/#conferencias-relevantes","title":"Conferencias Relevantes","text":"<ol> <li> <p>SIAM Conference on Computational Science and Engineering</p> <ul> <li>URL: https://www.siam.org/conferences/</li> <li>Conferencia l\u00edder en m\u00e9todos computacionales</li> </ul> </li> <li> <p>International Conference on Numerical Analysis and Applied Mathematics</p> <ul> <li>Conferencia especializada en an\u00e1lisis num\u00e9rico</li> </ul> </li> </ol>"},{"location":"referencias/#journals","title":"Journals","text":"<ol> <li> <p>Journal of Computational Physics</p> <ul> <li>Art\u00edculos sobre m\u00e9todos num\u00e9ricos avanzados</li> </ul> </li> <li> <p>SIAM Journal on Numerical Analysis</p> <ul> <li>An\u00e1lisis te\u00f3rico de m\u00e9todos num\u00e9ricos</li> </ul> </li> <li> <p>Numerische Mathematik</p> <ul> <li>Journal cl\u00e1sico de matem\u00e1ticas num\u00e9ricas</li> </ul> </li> </ol>"},{"location":"referencias/#herramientas-de-desarrollo","title":"Herramientas de Desarrollo","text":""},{"location":"referencias/#ides-y-editores","title":"IDEs y Editores","text":"<ol> <li> <p>Jupyter Lab</p> <ul> <li>URL: https://jupyter.org/</li> <li>Entorno interactivo para desarrollo cient\u00edfico</li> </ul> </li> <li> <p>VS Code with Python Extension</p> <ul> <li>URL: https://code.visualstudio.com/</li> <li>Editor moderno con excelente soporte para Python</li> </ul> </li> </ol>"},{"location":"referencias/#proyectos-relacionados","title":"Proyectos Relacionados","text":""},{"location":"referencias/#solvers-comerciales","title":"Solvers Comerciales","text":"<ol> <li> <p>COMSOL Multiphysics</p> <ul> <li>Software comercial para simulaci\u00f3n multif\u00edsica</li> </ul> </li> <li> <p>ANSYS Fluent</p> <ul> <li>Suite comercial de CFD</li> </ul> </li> </ol>"},{"location":"referencias/#solvers-open-source","title":"Solvers Open Source","text":"<ol> <li> <p>OpenFOAM</p> <ul> <li>URL: https://www.openfoam.com/</li> <li>Toolbox open-source para CFD</li> </ul> </li> <li> <p>deal.II</p> <ul> <li>URL: https://www.dealii.org/</li> <li>Biblioteca C++ para elementos finitos</li> </ul> </li> </ol>"},{"location":"referencias/#como-citar-este-proyecto","title":"C\u00f3mo Citar Este Proyecto","text":"<p>Si utilizas este solver en investigaci\u00f3n o trabajo acad\u00e9mico, puedes citarlo como:</p> <pre><code>@software{heat_equation_2d,\n  author = {Tu Nombre},\n  title = {Heat Equation 2D Solver},\n  year = {2024},\n  url = {https://github.com/tu-usuario/heat-equation-2d},\n  version = {1.0}\n}\n</code></pre>"},{"location":"referencias/#notas-finales","title":"Notas Finales","text":"<p>Esta lista de referencias proporciona una base s\u00f3lida para comprender la teor\u00eda y pr\u00e1ctica de la soluci\u00f3n num\u00e9rica de la ecuaci\u00f3n de calor. Se recomienda comenzar con los libros de texto introductorios y luego avanzar hacia temas m\u00e1s especializados seg\u00fan las necesidades del proyecto.</p> <p>Sugerencia</p> <p>Para un estudio sistem\u00e1tico, se recomienda seguir este orden:</p> <ol> <li>Fundamentos matem\u00e1ticos: Referencias [1-3, 18-19]</li> <li>M\u00e9todos num\u00e9ricos: Referencias [4-6]</li> <li>Implementaci\u00f3n pr\u00e1ctica: Referencias [11-12, 33-34]</li> <li>Aplicaciones: Referencias [16-17, 41-43]</li> </ol> <p>Actualizaciones</p> <p>Esta lista se actualizar\u00e1 peri\u00f3dicamente con nuevas referencias relevantes. Sugerencias de adiciones son bienvenidas.</p>"},{"location":"ejemplos/casos-prueba/","title":"Casos de Prueba","text":"<p>Esta secci\u00f3n presenta casos de prueba completos que combinan diferentes condiciones iniciales y de frontera para ilustrar diversos comportamientos f\u00edsicos.</p>"},{"location":"ejemplos/casos-prueba/#caso-1-enfriamiento-total","title":"Caso 1: Enfriamiento Total","text":""},{"location":"ejemplos/casos-prueba/#descripcion","title":"Descripci\u00f3n","text":"<p>Una regi\u00f3n inicialmente caliente que se enfr\u00eda completamente debido a fronteras fr\u00edas.</p>"},{"location":"ejemplos/casos-prueba/#configuracion","title":"Configuraci\u00f3n","text":"<pre><code>from heat_equation_2d import HeatEquation2D, DistribucionGaussiana\n\n# Todas las fronteras a temperatura 0\ncondiciones = {\n    'left':   {'type': 'dirichlet', 'valor': 0.0},\n    'right':  {'type': 'dirichlet', 'valor': 0.0},\n    'bottom': {'type': 'dirichlet', 'valor': 0.0},\n    'top':    {'type': 'dirichlet', 'valor': 0.0}\n}\n\nsolver = HeatEquation2D(\n    N=150,\n    M=300,\n    T=1.0,\n    condiciones_frontera=condiciones\n)\n\nsoluciones, tiempos = solver.solve(DistribucionGaussiana, save_every=10)\n</code></pre>"},{"location":"ejemplos/casos-prueba/#resultados-esperados","title":"Resultados Esperados","text":"Tiempo Temperatura M\u00e1xima Observaci\u00f3n t=0.0 100.0\u00b0C Pico inicial t=0.2 ~60\u00b0C Disminuci\u00f3n r\u00e1pida t=0.5 ~20\u00b0C Cerca de las fronteras t=1.0 ~5\u00b0C Casi completamente fr\u00edo"},{"location":"ejemplos/casos-prueba/#analisis","title":"An\u00e1lisis","text":"<ul> <li>El calor fluye hacia las fronteras y se disipa</li> <li>La temperatura m\u00e1xima decrece exponencialmente</li> <li>En \\(t \\to \\infty\\), toda la regi\u00f3n alcanza 0\u00b0C</li> </ul> <p>Conservaci\u00f3n de energ\u00eda</p> <p>La energ\u00eda total del sistema disminuye porque se transfiere al exterior a trav\u00e9s de las fronteras.</p>"},{"location":"ejemplos/casos-prueba/#caso-2-redistribucion-con-aislamiento","title":"Caso 2: Redistribuci\u00f3n con Aislamiento","text":""},{"location":"ejemplos/casos-prueba/#descripcion_1","title":"Descripci\u00f3n","text":"<p>Una regi\u00f3n con distribuci\u00f3n no uniforme de calor que se redistribuye sin p\u00e9rdida de energ\u00eda total.</p>"},{"location":"ejemplos/casos-prueba/#configuracion_1","title":"Configuraci\u00f3n","text":"<pre><code>from heat_equation_2d import HeatEquation2D, CuatroEsquinas\n\n# Todas las fronteras aisladas\ncondiciones = {\n    'left':   {'type': 'neumann', 'valor': 0.0},\n    'right':  {'type': 'neumann', 'valor': 0.0},\n    'bottom': {'type': 'neumann', 'valor': 0.0},\n    'top':    {'type': 'neumann', 'valor': 0.0}\n}\n\nsolver = HeatEquation2D(\n    N=150,\n    M=400,\n    T=1.5,\n    condiciones_frontera=condiciones\n)\n\nsoluciones, tiempos = solver.solve(CuatroEsquinas, save_every=10)\n</code></pre>"},{"location":"ejemplos/casos-prueba/#resultados-esperados_1","title":"Resultados Esperados","text":"Tiempo Temp. M\u00e1xima Temp. M\u00ednima Temp. Promedio t=0.0 100\u00b0C 0\u00b0C ~25\u00b0C t=0.3 ~75\u00b0C ~10\u00b0C ~25\u00b0C t=0.8 ~35\u00b0C ~20\u00b0C ~25\u00b0C t=1.5 ~27\u00b0C ~23\u00b0C ~25\u00b0C"},{"location":"ejemplos/casos-prueba/#analisis_1","title":"An\u00e1lisis","text":"<ul> <li>El calor se redistribuye uniformemente</li> <li>No hay p\u00e9rdida de energ\u00eda (fronteras aisladas)</li> <li>La temperatura promedio se conserva exactamente</li> <li>En \\(t \\to \\infty\\), la temperatura es uniforme en todo el dominio</li> </ul>"},{"location":"ejemplos/casos-prueba/#verificacion-de-conservacion","title":"Verificaci\u00f3n de Conservaci\u00f3n","text":"<pre><code># Calcular energ\u00eda total en cada tiempo\nh = solver.hx * solver.hy\nenergias = [np.sum(sol) * h for sol in soluciones]\n\nprint(\"Energ\u00eda total en cada tiempo:\")\nfor t, E in zip(tiempos, energias):\n    print(f\"  t={t:.3f}: E={E:.6f}\")\n\nprint(f\"\\nVariaci\u00f3n m\u00e1xima: {np.ptp(energias):.8f}\")\n</code></pre> <p>Resultado esperado: Variaci\u00f3n \\(&lt; 10^{-6}\\)</p>"},{"location":"ejemplos/casos-prueba/#caso-3-flujo-constante-por-una-frontera","title":"Caso 3: Flujo Constante por una Frontera","text":""},{"location":"ejemplos/casos-prueba/#descripcion_2","title":"Descripci\u00f3n","text":"<p>Una regi\u00f3n donde entra calor constantemente por una frontera mientras otras permanecen fr\u00edas.</p>"},{"location":"ejemplos/casos-prueba/#configuracion_2","title":"Configuraci\u00f3n","text":"<pre><code>from heat_equation_2d import HeatEquation2D\n\ndef InicialCero(x, y):\n    \"\"\"Regi\u00f3n inicialmente fr\u00eda\"\"\"\n    return 0.0\n\n# Flujo de calor por la izquierda, otras fronteras fr\u00edas\ncondiciones = {\n    'left':   {'type': 'neumann', 'valor': 10.0},  # Flujo entrante\n    'right':  {'type': 'dirichlet', 'valor': 0.0},\n    'bottom': {'type': 'dirichlet', 'valor': 0.0},\n    'top':    {'type': 'dirichlet', 'valor': 0.0}\n}\n\nsolver = HeatEquation2D(\n    N=150,\n    M=500,\n    T=2.0,\n    condiciones_frontera=condiciones\n)\n\nsoluciones, tiempos = solver.solve(InicialCero, save_every=10)\n</code></pre>"},{"location":"ejemplos/casos-prueba/#resultados-esperados_2","title":"Resultados Esperados","text":"<ul> <li>Inicialmente: Regi\u00f3n completamente fr\u00eda</li> <li>t \u2248 0.2: Calentamiento cerca de la frontera izquierda</li> <li>t \u2248 0.8: Gradiente de temperatura establecido</li> <li>t \u2192 \u221e: Estado estacionario con gradiente lineal</li> </ul>"},{"location":"ejemplos/casos-prueba/#estado-estacionario","title":"Estado Estacionario","text":"<p>En equilibrio (\\(\\frac{\\partial u}{\\partial t} = 0\\)), la soluci\u00f3n satisface:</p> \\[ \\nabla^2 u = 0 \\quad \\text{(Ecuaci\u00f3n de Laplace)} \\] <p>Con las condiciones dadas, se espera un gradiente aproximadamente lineal desde la frontera izquierda hacia las otras fronteras.</p>"},{"location":"ejemplos/casos-prueba/#caso-4-condiciones-mixtas-asimetricas","title":"Caso 4: Condiciones Mixtas Asim\u00e9tricas","text":""},{"location":"ejemplos/casos-prueba/#descripcion_3","title":"Descripci\u00f3n","text":"<p>Combinaci\u00f3n de diferentes tipos de condiciones en cada frontera para crear patrones de flujo complejos.</p>"},{"location":"ejemplos/casos-prueba/#configuracion_3","title":"Configuraci\u00f3n","text":"<pre><code>from heat_equation_2d import HeatEquation2D, Anillo\n\n# Frontera izquierda caliente, derecha fr\u00eda, superior/inferior aisladas\ncondiciones = {\n    'left':   {'type': 'dirichlet', 'valor': 80.0},   # Caliente\n    'right':  {'type': 'dirichlet', 'valor': 20.0},   # Fr\u00eda\n    'bottom': {'type': 'neumann', 'valor': 0.0},      # Aislada\n    'top':    {'type': 'neumann', 'valor': 0.0}       # Aislada\n}\n\nsolver = HeatEquation2D(\n    N=150,\n    M=400,\n    T=1.0,\n    condiciones_frontera=condiciones\n)\n\nsoluciones, tiempos = solver.solve(Anillo, save_every=10)\n</code></pre>"},{"location":"ejemplos/casos-prueba/#resultados-esperados_3","title":"Resultados Esperados","text":"<ul> <li>Flujo dominante: De izquierda (caliente) a derecha (fr\u00eda)</li> <li>Fronteras superior/inferior: No afectan el flujo (aisladas)</li> <li>Patr\u00f3n final: Gradiente aproximadamente horizontal</li> </ul>"},{"location":"ejemplos/casos-prueba/#analisis-del-flujo","title":"An\u00e1lisis del Flujo","text":"<pre><code># Calcular flujo de calor en direcci\u00f3n x\ndef calcular_flujo_x(sol, hx):\n    \"\"\"Calcula \u2202u/\u2202x usando diferencias centrales\"\"\"\n    flujo = np.zeros_like(sol)\n    flujo[:, 1:-1] = (sol[:, 2:] - sol[:, :-2]) / (2 * hx)\n    return flujo\n\n# Para \u00faltima soluci\u00f3n\nflujo_x = calcular_flujo_x(soluciones[-1], solver.hx)\nprint(f\"Flujo promedio en x: {np.mean(flujo_x):.4f}\")\n</code></pre>"},{"location":"ejemplos/casos-prueba/#caso-5-calentamiento-periodico","title":"Caso 5: Calentamiento Peri\u00f3dico","text":""},{"location":"ejemplos/casos-prueba/#descripcion_4","title":"Descripci\u00f3n","text":"<p>Una frontera con temperatura que oscila peri\u00f3dicamente en el tiempo.</p>"},{"location":"ejemplos/casos-prueba/#configuracion_4","title":"Configuraci\u00f3n","text":"<pre><code>from heat_equation_2d import HeatEquation2D, DistribucionGaussiana\nimport numpy as np\n\n# Frontera izquierda con temperatura oscilante\ndef temp_oscilante(t, pos):\n    \"\"\"Temperatura que oscila sinusoidalmente\"\"\"\n    T_media = 50.0\n    amplitud = 30.0\n    periodo = 0.5\n    return T_media + amplitud * np.sin(2 * np.pi * t / periodo)\n\ncondiciones = {\n    'left':   {'type': 'dirichlet', 'valor': temp_oscilante},\n    'right':  {'type': 'dirichlet', 'valor': 0.0},\n    'bottom': {'type': 'neumann', 'valor': 0.0},\n    'top':    {'type': 'neumann', 'valor': 0.0}\n}\n\nsolver = HeatEquation2D(\n    N=150,\n    M=600,\n    T=3.0,  # Simular varios periodos\n    condiciones_frontera=condiciones\n)\n\nsoluciones, tiempos = solver.solve(DistribucionGaussiana, save_every=10)\n</code></pre>"},{"location":"ejemplos/casos-prueba/#resultados-esperados_4","title":"Resultados Esperados","text":"<ul> <li>Onda t\u00e9rmica propag\u00e1ndose desde la frontera izquierda</li> <li>Atenuaci\u00f3n: La amplitud de la oscilaci\u00f3n disminuye con la distancia</li> <li>Desfase: La oscilaci\u00f3n se retrasa a medida que nos alejamos de la frontera</li> </ul>"},{"location":"ejemplos/casos-prueba/#analisis-de-temperatura-en-puntos-especificos","title":"An\u00e1lisis de Temperatura en Puntos Espec\u00edficos","text":"<pre><code># Extraer temperatura en x = 0.25 (cerca de frontera) y x = 0.75 (lejos)\nidx_cerca = int(0.25 * solver.N)\nidx_lejos = int(0.75 * solver.N)\nj_medio = solver.N // 2\n\ntemp_cerca = [sol[j_medio, idx_cerca] for sol in soluciones]\ntemp_lejos = [sol[j_medio, idx_lejos] for sol in soluciones]\n\nplt.figure(figsize=(10, 6))\nplt.plot(tiempos, temp_cerca, label='x=0.25 (cerca)', linewidth=2)\nplt.plot(tiempos, temp_lejos, label='x=0.75 (lejos)', linewidth=2)\nplt.xlabel('Tiempo')\nplt.ylabel('Temperatura')\nplt.title('Respuesta a calentamiento peri\u00f3dico')\nplt.legend()\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"ejemplos/casos-prueba/#caso-6-test-de-convergencia","title":"Caso 6: Test de Convergencia","text":""},{"location":"ejemplos/casos-prueba/#descripcion_5","title":"Descripci\u00f3n","text":"<p>Verificar que la soluci\u00f3n converge al refinar la malla espacial y temporal.</p>"},{"location":"ejemplos/casos-prueba/#configuracion_5","title":"Configuraci\u00f3n","text":"<pre><code>from heat_equation_2d import HeatEquation2D, DistribucionGaussiana\n\ncondiciones = {\n    'left':   {'type': 'dirichlet', 'valor': 0.0},\n    'right':  {'type': 'dirichlet', 'valor': 0.0},\n    'bottom': {'type': 'dirichlet', 'valor': 0.0},\n    'top':    {'type': 'dirichlet', 'valor': 0.0}\n}\n\n# Resolver con diferentes resoluciones\nresoluciones = [\n    (50, 100),    # Grueso\n    (100, 200),   # Medio\n    (150, 300),   # Fino\n    (200, 400)    # Muy fino\n]\n\nsoluciones_finales = []\n\nfor N, M in resoluciones:\n    solver = HeatEquation2D(\n        N=N, M=M, T=0.5,\n        condiciones_frontera=condiciones\n    )\n    sols, _ = solver.solve(DistribucionGaussiana)\n    soluciones_finales.append(sols[-1])\n    print(f\"N={N}, M={M}: Temp. m\u00e1x. final = {sols[-1].max():.6f}\")\n</code></pre>"},{"location":"ejemplos/casos-prueba/#analisis-de-convergencia","title":"An\u00e1lisis de Convergencia","text":"<pre><code># Calcular diferencia entre soluciones sucesivas\nfor i in range(1, len(soluciones_finales)):\n    # Interpolar soluci\u00f3n gruesa a malla fina para comparaci\u00f3n\n    sol_gruesa = soluciones_finales[i-1]\n    sol_fina = soluciones_finales[i]\n\n    # Diferencia relativa (simplificada)\n    diff = abs(sol_fina.max() - sol_gruesa.max()) / sol_fina.max()\n    print(f\"Diferencia {i-1}\u2192{i}: {diff:.6f} ({diff*100:.3f}%)\")\n</code></pre> <p>Resultado esperado: Las diferencias deben disminuir al refinar la malla, confirmando convergencia.</p>"},{"location":"ejemplos/casos-prueba/#caso-7-simetria","title":"Caso 7: Simetr\u00eda","text":""},{"location":"ejemplos/casos-prueba/#descripcion_6","title":"Descripci\u00f3n","text":"<p>Verificar que condiciones sim\u00e9tricas producen soluciones sim\u00e9tricas.</p>"},{"location":"ejemplos/casos-prueba/#configuracion_6","title":"Configuraci\u00f3n","text":"<pre><code>from heat_equation_2d import HeatEquation2D, DistribucionGaussiana\n\n# Condiciones completamente sim\u00e9tricas\ncondiciones = {\n    'left':   {'type': 'neumann', 'valor': 0.0},\n    'right':  {'type': 'neumann', 'valor': 0.0},\n    'bottom': {'type': 'neumann', 'valor': 0.0},\n    'top':    {'type': 'neumann', 'valor': 0.0}\n}\n\nsolver = HeatEquation2D(\n    N=150, M=200, T=0.5,\n    condiciones_frontera=condiciones\n)\n\nsoluciones, tiempos = solver.solve(DistribucionGaussiana)\n</code></pre>"},{"location":"ejemplos/casos-prueba/#verificacion-de-simetria","title":"Verificaci\u00f3n de Simetr\u00eda","text":"<pre><code># La soluci\u00f3n debe ser sim\u00e9trica respecto a x=0.5 e y=0.5\nsol_final = soluciones[-1]\nN = sol_final.shape[0]\n\n# Simetr\u00eda en x\ndiff_x = np.abs(sol_final - np.fliplr(sol_final))\nprint(f\"Error de simetr\u00eda en x: {diff_x.max():.8f}\")\n\n# Simetr\u00eda en y\ndiff_y = np.abs(sol_final - np.flipud(sol_final))\nprint(f\"Error de simetr\u00eda en y: {diff_y.max():.8f}\")\n</code></pre> <p>Resultado esperado: Errores \\(&lt; 10^{-10}\\) (errores de redondeo num\u00e9rico)</p>"},{"location":"ejemplos/casos-prueba/#resumen-de-casos-de-prueba","title":"Resumen de Casos de Prueba","text":"Caso Condiciones Iniciales Fronteras Comportamiento Clave 1. Enfriamiento Gaussiana Dirichlet (T=0) Temperatura \u2192 0 2. Redistribuci\u00f3n Cuatro Esquinas Neumann (aislado) Energ\u00eda conservada 3. Flujo Constante Cero Neumann (flujo) + Dirichlet Estado estacionario 4. Mixtas Anillo Mixtas asim\u00e9tricas Flujo direccional 5. Peri\u00f3dico Gaussiana Dirichlet oscilante Onda t\u00e9rmica 6. Convergencia Gaussiana Dirichlet Verificaci\u00f3n num\u00e9rica 7. Simetr\u00eda Gaussiana Neumann sim\u00e9trico Simetr\u00eda preservada"},{"location":"ejemplos/casos-prueba/#script-de-prueba-automatizado","title":"Script de Prueba Automatizado","text":"<pre><code>def ejecutar_casos_prueba():\n    \"\"\"Ejecuta todos los casos de prueba y genera reporte\"\"\"\n\n    casos = [\n        (\"Enfriamiento\", caso1_enfriamiento),\n        (\"Redistribuci\u00f3n\", caso2_redistribucion),\n        (\"Flujo constante\", caso3_flujo_constante),\n        (\"Mixtas\", caso4_mixtas),\n        (\"Peri\u00f3dico\", caso5_periodico),\n        (\"Convergencia\", caso6_convergencia),\n        (\"Simetr\u00eda\", caso7_simetria)\n    ]\n\n    resultados = []\n\n    for nombre, funcion_caso in casos:\n        print(f\"\\n{'='*60}\")\n        print(f\"Ejecutando: {nombre}\")\n        print('='*60)\n\n        try:\n            resultado = funcion_caso()\n            resultados.append((nombre, \"\u2713 Exitoso\", resultado))\n            print(f\"\u2713 {nombre} completado exitosamente\")\n        except Exception as e:\n            resultados.append((nombre, \"\u2717 Fall\u00f3\", str(e)))\n            print(f\"\u2717 {nombre} fall\u00f3: {e}\")\n\n    # Generar reporte\n    print(\"\\n\" + \"=\"*60)\n    print(\"RESUMEN DE PRUEBAS\")\n    print(\"=\"*60)\n    for nombre, estado, info in resultados:\n        print(f\"{estado} {nombre}\")\n\n    return resultados\n\n# Ejecutar todas las pruebas\nresultados = ejecutar_casos_prueba()\n</code></pre> <p>Pr\u00f3ximo paso: Revisa An\u00e1lisis de Resultados para t\u00e9cnicas de post-procesamiento y visualizaci\u00f3n avanzada.</p>"},{"location":"implementacion/cpp/","title":"C++","text":""},{"location":"implementacion/cpp/#metodo-iterativo-gauss-seidel","title":"M\u00e9todo Iterativo Gauss-Seidel","text":"<p>Para resolver Ax = b, Gauss-Seidel actualiza cada componente secuencialmente:</p> \\[x_i^{\\text{new}} = \\frac{1}{a_{ii}} \\left( b_i - \\sum_{j&lt;i} a_{ij} x_j^{\\text{new}} - \\sum_{j&gt;i} a_{ij} x_j^{\\text{old}} \\right)\\]"},{"location":"implementacion/cpp/#pseudocodigo","title":"Pseudoc\u00f3digo","text":"<pre><code>x = 0\nrepeat\n    max_diff = 0\n    for i = 1..N:\n        sigma = sum_{j != i} a[i,j] * x[j]\n        x_new = (b[i] - sigma)/a[i,i]\n        max_diff = max(max_diff, |x_new - x[i]|)\n        x[i] = x_new\nuntil max_diff &lt; tol\n</code></pre>"},{"location":"implementacion/cpp/#convergencia","title":"Convergencia","text":"<p>La principal diferencia con el m\u00e9todo de Jacobi es que Gauss-Seidel utiliza valores reci\u00e9n calculados tan pronto como est\u00e1n disponibles; esta diferencia hace que Gauss-Seidel converja m\u00e1s r\u00e1pido que Jacobi en la mayor\u00eda de los casos.</p>"},{"location":"implementacion/cpp/#condiciones-de-convergencia","title":"Condiciones de convergencia","text":"<ol> <li>Matriz Diagonalmente Dominante:</li> </ol> \\[|a_{ii}| &gt; \\sum_{j \\neq i} |a_{ij}| \\quad \\text{para todo } i\\] <ol> <li> <p>Matriz Sim\u00e9trica Definida Positiva (SPD):</p> <ul> <li>\\(A = A^T\\) (sim\u00e9trica)</li> <li>Todos los valores propios &gt; 0</li> </ul> </li> <li> <p>Matriz con Elementos Positivos en la Diagonal: Si \\(a_{ii} &gt; 0\\) y la matriz es irreducible, converge.</p> </li> </ol> <p>Propiamente, para el sistema \\((I - kA)u^{n+1} = u^n\\):</p> <ul> <li>La matriz \\(I - kA\\) es diagonalmente dominante cuando \\(k\\) es peque\u00f1o</li> <li>Es sim\u00e9trica definida positiva porque \\(A\\) (Laplaciano discreto) es SPD</li> <li>Esto garantiza la convergencia de Gauss-Seidel</li> </ul>"},{"location":"implementacion/cpp/#ejemplo","title":"Ejemplo","text":"<p>Supongamos el sistema:</p> \\[\\begin{bmatrix} 4 &amp; 1 \\\\ 1 &amp; 3 \\end{bmatrix} \\begin{bmatrix} x_1 \\\\ x_2 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}\\] <p>Gauss-Seidel actualiza primero \\(x_1\\) usando \\(x_2\\) antiguo, luego \\(x_2\\) usando el nuevo \\(x_1\\). Tras varias iteraciones, converge a la soluci\u00f3n exacta.</p>"},{"location":"implementacion/cpp/#esquema-red-black","title":"Esquema Red-Black","text":"<p>Para mejorar la paralelizaci\u00f3n y la convergencia, se colorea la malla como un tablero de ajedrez:</p> <ul> <li>Nodos rojos: \\((i + j) \\mod 2 = 0\\)</li> <li>Nodos negros: \\((i + j) \\mod 2 = 1\\)</li> </ul> <p>Primero se actualizan los nodos rojos usando valores negros antiguos, luego los negros usando valores rojos nuevos. Esto acelera la convergencia respecto al Gauss-Seidel est\u00e1ndar.</p>"},{"location":"implementacion/cpp/#condiciones-de-frontera","title":"Condiciones de frontera","text":"<p>El c\u00f3digo permite elegir condiciones de frontera:</p> <ul> <li>Dirichlet homog\u00e9nea (\\(u = 0\\)): paredes fr\u00edas, el calor se fuga y la soluci\u00f3n tiende a cero.</li> <li>Dirichlet fija (\\(u = T_{\\text{borde}}\\)): se fuerzan temperaturas de borde, la soluci\u00f3n alcanza equilibrio estacionario.</li> <li>Neumann (\\(\\frac{\\partial u}{\\partial n} = 0\\)): frontera aislada, no hay transferencia de calor hacia afuera, la energ\u00eda total se conserva.</li> </ul>"},{"location":"implementacion/cpp/#ejemplo-fisico","title":"Ejemplo f\u00edsico","text":"<p>Si se coloca un pulso de calor inicial en el centro:</p> <ul> <li>Con Dirichlet \\(u = 0\\), el pulso se disipa r\u00e1pidamente.</li> <li>Con Dirichlet fija, el sistema alcanza un estado estacionario con temperaturas de borde constantes.</li> <li>Con Neumann, el calor permanece dentro del dominio y se redistribuye hasta homogenizarse.</li> </ul>"},{"location":"implementacion/cpp/#flujo-completo-del-programa","title":"Flujo completo del programa","text":"<ol> <li>Se imprimen opciones de frontera y el usuario elige una.</li> <li>Se construye el objeto solver correspondiente.</li> <li>Se genera la condici\u00f3n inicial (ejemplo: distribuci\u00f3n gaussiana).</li> <li>Para cada paso de tiempo:     (a) Se ejecuta el solver iterativo.     (b) Se guarda un snapshot si corresponde.     (c) Se analiza m\u00e1ximo y m\u00ednimo de la temperatura.</li> </ol>"},{"location":"implementacion/cpp/#relacion-entre-euler-implicito-y-gauss-seidel","title":"Relaci\u00f3n entre Euler Impl\u00edcito y Gauss-Seidel","text":"<ul> <li>Euler impl\u00edcito convierte la PDE en un sistema lineal.</li> <li>Gauss-Seidel (o Red-Black) es el m\u00e9todo usado para resolver ese sistema.</li> <li>En cada paso temporal se ejecutan m\u00faltiples iteraciones de Gauss-Seidel hasta convergencia.</li> </ul>"},{"location":"implementacion/python/","title":"Implementaci\u00f3n en Python","text":"<p>La implementaci\u00f3n en Python utiliza NumPy para operaciones matriciales y SciPy para resolver el sistema lineal disperso de manera eficiente.</p>"},{"location":"implementacion/python/#arquitectura-del-codigo","title":"Arquitectura del C\u00f3digo","text":""},{"location":"implementacion/python/#clase-principal-heatequation2d","title":"Clase Principal: <code>HeatEquation2D</code>","text":"<pre><code>class HeatEquation2D:\n    def __init__(self, N=150, M=200, T=0.5, a=1.0, b=1.0, c=1.0,\n                 condiciones_frontera=None)\n    def MatrizLaplaciano(self)\n    def VectorRHS(self, tn, u_prev)\n    def obtener_valor_frontera(self, lado, t, pos)\n    def solve(self, u0_func, save_every=1)\n</code></pre>"},{"location":"implementacion/python/#componentes-principales","title":"Componentes Principales","text":""},{"location":"implementacion/python/#1-inicializacion","title":"1. Inicializaci\u00f3n","text":"<p>Aqui simplemente se definen los parametros con los que se van a trabajar y se definen como atributos de la clase:</p> <pre><code>def __init__(self, N=150, M=200, T=0.5, a=1.0, b=1.0, c=1.0,\n             condiciones_frontera=None):\n    self.N = N\n    self.M = M\n    self.T = T\n    self.a = a\n    self.b = b\n    self.c = c\n\n    # Pasos espaciales y temporales\n    self.hx = a / (N + 1)\n    self.hy = b / (N + 1)\n    self.k = T / M\n\n    # Par\u00e1metros de discretizaci\u00f3n\n    self.mux = (c**2 * self.k) / self.hx**2\n    self.muy = (c**2 * self.k) / self.hy**2\n\n    # Malla espacial (solo puntos interiores)\n    self.x = np.linspace(self.hx, a - self.hx, N)\n    self.y = np.linspace(self.hy, b - self.hy, N)\n    self.X, self.Y = np.meshgrid(self.x, self.y)\n\n    # Construir matriz del sistema\n    self.A = self.MatrizLaplaciano()\n</code></pre>"},{"location":"implementacion/python/#2-construccion-de-la-matriz-del-sistema","title":"2. Construcci\u00f3n de la Matriz del Sistema","text":"<p>Se elige construir la matriz A en formato LIL ya que es un formato eficiente para construir matrices dispersas elemento por elemento. El elemento idx proyecta los elementos \\((i,j)\\) en una dimension ordenandolos por fila. Ademas, se guarda como csr para optimizar las operaciones algebraicas.</p> <pre><code>def MatrizLaplaciano(self):\n        N = self.N\n        A = lil_matrix((N * N, N * N))\n\n        # Pre-calcular tipos de condiciones para cada borde\n        left_type = self.condiciones_frontera['left']['type']\n        right_type = self.condiciones_frontera['right']['type']\n        bottom_type = self.condiciones_frontera['bottom']['type']\n        top_type = self.condiciones_frontera['top']['type']\n\n        for j in range(N):\n            for i in range(N):\n                idx = j * N + i\n\n                # Diagonal: siempre 1 + 2\u03bcx + 2\u03bcy\n                A[idx, idx] = 1.0 + 2.0 * self.mux + 2.0 * self.muy\n\n                # Vecinos en x\n                # Est\u00e1 en borde izquierdo\n                if i == 0:\n                    if left_type == 'neumann':\n                        # En borde izquierdo con Neumann\n                        # No hay coeficiente para vecino izquierdo (fantasma)\n                        # Pero el vecino derecho (si existe) tiene -2\u03bcx\n                        if i &lt; N - 1:  # Existe vecino derecho\n                            A[idx, idx + 1] = -2.0 * self.mux\n                    else:\n                        # Dirichlet en borde izquierdo\n                        # Coeficiente normal para vecino derecho\n                        if i &lt; N - 1:\n                            A[idx, idx + 1] = -self.mux\n                # Est\u00e1 en borde derecho\n                elif i == N - 1:\n                    if right_type == 'neumann':\n                        # En borde derecho con Neumann\n                        # Vecino izquierdo tiene -2\u03bcx\n                        A[idx, idx - 1] = -2.0 * self.mux\n                    else:\n                        # Dirichlet en borde derecho\n                        # Coeficiente normal para vecino izquierdo\n                        A[idx, idx - 1] = -self.mux\n                else:\n                    # Punto interior en x\n                    A[idx, idx - 1] = -self.mux  # Vecino izquierdo\n                    A[idx, idx + 1] = -self.mux  # Vecino derecho\n\n                # Vecinos en Y\n\n                # Est\u00e1 en borde inferior\n                if j == 0:\n                    if bottom_type == 'neumann':\n                        # En borde inferior con Neumann\n                        # Vecino superior (si existe) tiene -2\u03bcy\n                        if j &lt; N - 1:\n                            A[idx, idx + N] = -2.0 * self.muy\n                    else:\n                        # Dirichlet en borde inferior\n                        if j &lt; N - 1:\n                            A[idx, idx + N] = -self.muy\n                # Est\u00e1 en borde superior\n                elif j == N - 1:\n                    if top_type == 'neumann':\n                        # En borde superior con Neumann\n                        # Vecino inferior tiene -2\u03bcy\n                        A[idx, idx - N] = -2.0 * self.muy\n                    else:\n                        # Dirichlet en borde superior\n                        A[idx, idx - N] = -self.muy\n                else:\n                    # Punto interior en y\n                    A[idx, idx - N] = -self.muy  # Vecino inferior\n                    A[idx, idx + N] = -self.muy  # Vecino superior\n\n        return A.tocsr()\n</code></pre>"},{"location":"implementacion/python/#3-construccion-del-vector-rhs","title":"3. Construcci\u00f3n del Vector RHS","text":"<p>Aqui simplemente se construye el vector segun el tipo de condicion y el borde que se tenga.</p> <pre><code>def VectorRHS(self, tn, u_prev):\n        \"\"\"\n        aqui se construye el vector del lado derecho\n\n        se dedujo que:\n        - borde izquierdo Neumann:  b = u\u207f - 2\u03bcx\u00b7hx\u00b7g\n        - borde derecho Neumann:    b = u\u207f + 2\u03bcx\u00b7hx\u00b7g\n        - borde inferior Neumann:   b = u\u207f - 2\u03bcy\u00b7hy\u00b7g\n        - borde superior Neumann:   b = u\u207f + 2\u03bcy\u00b7hy\u00b7g\n        - Dirichlet:                b = u\u207f + \u03bc\u00b7g\n\n        esto es lo que se desarrolla aca\n        \"\"\"\n        N = self.N\n        b = u_prev.copy()  # empezamos con las temperaturas anteriores (o sea, u\u207f)\n\n        # bordes izquierdo y derecho (i fijo)\n        for j in range(N):\n            y_pos = self.y[j]  # posicion en y\n\n            # borde izquierdo (i=0)\n            idx_left = j * N  # j*N + 0\n            if self.condiciones_frontera['left']['type'] == 'dirichlet':\n                # Dirichlet: u = g en el borde\n                g_left = self.condiciones_frontera['left']['valor']\n                # se a\u00f1ade el t\u00e9rmino necesario\n                b[idx_left] += self.mux * g_left\n\n            elif self.condiciones_frontera['left']['type'] == 'neumann':\n                # Neumann: \u2202u/\u2202x = g en el borde\n                g_left = self.condiciones_frontera['left']['valor']\n                # se a\u00f1ade el t\u00e9rmino necesario\n                b[idx_left] -= 2.0 * self.mux * self.hx * g_left\n\n            # borde derecho (i=N-1), todo es la misma l\u00f3gica que para el borde\n            # izq\n            idx_right = j * N + (N - 1)\n            if self.condiciones_frontera['right']['type'] == 'dirichlet':\n                g_right = self.condiciones_frontera['right']['valor']\n                b[idx_right] += self.mux * g_right\n\n            elif self.condiciones_frontera['right']['type'] == 'neumann':\n                g_right = self.condiciones_frontera['right']['valor']\n                b[idx_right] += 2.0 * self.mux * self.hx * g_right\n\n        # bordes inferior y superior (j fijo), igual todo es con la misma\n        # l\u00f3gica y se usan las mismas f\u00f3rmulas\n        for i in range(N):\n            x_pos = self.x[i]  # posici\u00f3n en x\n\n            # borde inferior (j=0)\n            idx_bottom = i  # 0*N + i = i\n            if self.condiciones_frontera['bottom']['type'] == 'dirichlet':\n                g_bottom = self.condiciones_frontera['bottom']['valor']\n                b[idx_bottom] += self.muy * g_bottom\n\n            elif self.condiciones_frontera['bottom']['type'] == 'neumann':\n                g_bottom = self.condiciones_frontera['bottom']['valor']\n                b[idx_bottom] -= 2.0 * self.muy * self.hy * g_bottom\n\n            # borde superior (j=N-1)\n            idx_top = (N - 1) * N + i\n            if self.condiciones_frontera['top']['type'] == 'dirichlet':\n                g_top = self.obtener_valor_frontera['top']['valor']\n                b[idx_top] += self.muy * g_top\n\n            elif self.condiciones_frontera['top']['type'] == 'neumann':\n                g_top = self.condiciones_frontera['top']['valor']\n                b[idx_top] += 2.0 * self.muy * self.hy * g_top\n\n        return b\n</code></pre>"},{"location":"implementacion/python/#4-solver-principal","title":"4. Solver Principal","text":"<p>Se inicializa el vector \\(u0\\) con la condicion inicial evaluada en cada puntos y se almacena en la lista de soluciones.</p> <p>Despues hay un bucle temporal en el que para cado paso n se calcula el tiempo actual, ademas construye el vector b basandose en \\(u_prev\\) y en las condiciones de frontera en el tiempo actual.</p> <p>Con esto ya armado, se resuelve para u_actual con la funcion spsolve, que es una funcion de SciPy para resolver sistemas lineales dispersos.</p> <pre><code>def solve(self, u0_func, save_every=1):\n        # resuelve la ecuaci\u00f3n de calor\n        N = self.N\n\n       # condicion inicial\n        u0 = np.zeros(N * N)\n        for j in range(N):\n            for i in range(N):\n                idx = j * N + i\n                u0[idx] = u0_func(self.x[i], self.y[j])\n\n        soluciones = [u0.reshape(N, N).copy()]\n        tiempos = [0.0]\n        u_prev = u0\n\n        print(f\"Resolviendo...\")\n\n        # evoluci\u00f3n temporal\n        for n in range(1, self.M + 1):\n            tn = n * self.k  # tiempo actual\n\n            # se construye el vector del lado derecho\n            b = self.VectorRHS(tn, u_prev)\n\n            # se resuelve sistema lineal A\u00b7u^{n+1} = b\n            u_actual = spsolve(self.A, b)\n\n            if n % save_every == 0 or n == self.M:\n                soluciones.append(u_actual.reshape(N, N).copy())\n                tiempos.append(tn)\n\n            u_prev = u_actual\n\n        return soluciones, tiempos\n</code></pre>"},{"location":"implementacion/python/#condiciones","title":"Condiciones","text":"<p>Se ponen cinco condiciones iniciales con una temperatura inicial de 100 grados celsius:</p>"},{"location":"implementacion/python/#1-distribucion-gaussiana","title":"1. Distribuci\u00f3n Gaussiana","text":"<pre><code>def DistribucionGaussiana(x, y):\n    \"\"\"Pico gaussiano centrado en (0.5, 0.5)\"\"\"\n    return 100 * np.exp(-50 * ((x - 0.5)**2 + (y - 0.5)**2))\n</code></pre>"},{"location":"implementacion/python/#2-anillo","title":"2. Anillo","text":"<pre><code>def Anillo(x, y):\n    \"\"\"Distribuci\u00f3n en forma de anillo\"\"\"\n    r = np.sqrt((x - 0.5)**2 + (y - 0.5)**2)\n    return 100 * np.exp(-200 * (r - 0.3)**2)\n</code></pre>"},{"location":"implementacion/python/#3-diagonal","title":"3. Diagonal","text":"<pre><code>def Diagonal(x, y):\n    \"\"\"Franja diagonal caliente\"\"\"\n    return 100 * np.exp(-100 * (x - y)**2)\n</code></pre>"},{"location":"implementacion/python/#4-forma-de-u","title":"4. Forma de U","text":"<pre><code>def FormaU(x, y):\n    \"\"\"Tres puntos calientes formando U\"\"\"\n    left = np.exp(-200 * ((x - 0.25)**2 + (y - 0.5)**2))\n    right = np.exp(-200 * ((x - 0.75)**2 + (y - 0.5)**2))\n    bottom = np.exp(-200 * ((x - 0.5)**2 + (y - 0.25)**2))\n    return 100 * (left + right + bottom)\n</code></pre>"},{"location":"implementacion/python/#5-cuatro-esquinas","title":"5. Cuatro Esquinas","text":"<pre><code>def CuatroEsquinas(x, y):\n    \"\"\"Cuatro puntos calientes en las esquinas\"\"\"\n    sigma = 0.08\n    return 100 * (\n        np.exp(-((x - 0.1)**2 + (y - 0.1)**2) / (2 * sigma**2)) +\n        np.exp(-((x - 0.9)**2 + (y - 0.1)**2) / (2 * sigma**2)) +\n        np.exp(-((x - 0.1)**2 + (y - 0.9)**2) / (2 * sigma**2)) +\n        np.exp(-((x - 0.9)**2 + (y - 0.9)**2) / (2 * sigma**2))\n    )\n</code></pre> <p>Ademas de esto, se implementa una funcion que imprime las temperaturas maximas y minimas en el sistema en un determinado tiempo.</p> <pre><code>def analyze_min_max(soluciones, tiempos):\n    print(\"\\nAn\u00e1lisis de temperatura:\")\n    for i, (sol, t) in enumerate(zip(soluciones, tiempos)):\n        u_max = sol.max()\n        u_min = sol.min()\n        print(f\"  t={t:.4f} | Temp. m\u00e1x: {u_max:.4f} | Temp. m\u00edn: {u_min:.4f}\")\n</code></pre>"},{"location":"implementacion/python/#menu-interactivo","title":"Menu interactivo","text":"<p>Se implementaron funciones que permiten al usuario elegir las condiciones iniciales y las condiciones de frontera para cada uno de los bordes de la malla.</p> <pre><code>def seleccionar_condicion_inicial():\n    \"\"\"\n    Permite al usuario seleccionar una condici\u00f3n inicial.\n    \"\"\"\n    print(\"Selecci\u00f3n de condici\u00f3n inicial\")\n    print(\"  1. Distribuci\u00f3n Gaussiana\")\n    print(\"  2. Anillo\")\n    print(\"  3. Diagonal\")\n    print(\"  4. Forma de U\")\n    print(\"  5. Cuatro esquinas\")\n\n    condiciones = {\n        1: (\"Distribuci\u00f3n Gaussiana\", DistribucionGaussiana),\n        2: (\"Anillo\", Anillo),\n        3: (\"Diagonal\", Diagonal),\n        4: (\"Forma de U\", FormaU),\n        5: (\"Cuatro esquinas\", CuatroEsquinas)\n    }\n\n    while True:\n\n\n      while True:\n        try:\n            opcion = int(input(\"\\nSeleccione una opci\u00f3n (1-5): \").strip())\n            if opcion in condiciones:\n                nombre, funcion = condiciones[opcion]\n                print(f\"\\nSeleccionado: {nombre}\")\n                return funcion\n            else:\n                print(\"Error: Ingrese un n\u00famero entre 1 y 4\")\n        except ValueError:\n            print(\"Error: Ingrese un n\u00famero v\u00e1lido\")\n\n\ndef solicitar_condiciones_frontera():\n    \"\"\"\n    Solicita al usuario las condiciones de frontera para cada lado del dominio.\n    \"\"\"\n    print(\"Configuraci\u00f3n de condiciones de frontera\")\n    print(\"\\nTipos de condici\u00f3n:\")\n    print(\"  Dirichlet: temperatura fija en la frontera\")\n    print(\"  Neumann: flujo de calor en la frontera (0 = aislado)\")\n\n    condiciones_frontera = {}\n    lados = ['left', 'right', 'bottom', 'top']\n    lado_nombres = {\n        'left': 'Izquierdo',\n        'right': 'Derecho',\n        'bottom': 'Inferior',\n        'top': 'Superior'\n    }\n\n    for lado in lados:\n        print(f\"\\n--- Borde {lado_nombres[lado]} ---\")\n\n        while True:\n            tipo = input(f\"Tipo de condici\u00f3n (dirichlet/neumann): \").strip().lower()\n            if tipo in ['dirichlet', 'neumann', 'd', 'n']:\n                if tipo == 'd':\n                    tipo = 'dirichlet'\n                elif tipo == 'n':\n                    tipo = 'neumann'\n                break\n            print(\"Error: Ingrese 'dirichlet' (o 'd') o 'neumann' (o 'n')\")\n\n        while True:\n            try:\n                valor_str = input(f\"Valor: \").strip()\n                valor = float(valor_str)\n                break\n            except ValueError:\n                print(\"Error: Ingrese un n\u00famero v\u00e1lido\")\n\n        condiciones_frontera[lado] = {'type': tipo, 'valor': valor}\n\n    return condiciones_frontera\n</code></pre>"},{"location":"implementacion/python/#visualizacion-y-animacion","title":"Visualizaci\u00f3n y Animaci\u00f3n","text":""},{"location":"implementacion/python/#funcion-de-animacion","title":"Funci\u00f3n de Animaci\u00f3n","text":"<pre><code>def crear_animacion(soluciones, tiempos, titulo, condiciones_frontera, \n                   intervalo=500):\n    \"\"\"\n    Crea animaci\u00f3n de la evoluci\u00f3n de temperatura.\n\n    Par\u00e1metros:\n    -----------\n    soluciones : list\n        Lista de arrays 2D con soluciones\n    tiempos : list\n        Tiempos correspondientes\n    titulo : str\n        T\u00edtulo de la animaci\u00f3n\n    condiciones_frontera : dict\n        Condiciones de frontera usadas\n    intervalo : int\n        Milisegundos entre frames\n    \"\"\"\n    fig, ax = plt.subplots(figsize=(10, 8))\n\n    # Rango de colores consistente\n    vmin = min(sol.min() for sol in soluciones)\n    vmax = max(sol.max() for sol in soluciones)\n\n    # Imagen inicial\n    im = ax.imshow(soluciones[0], cmap='hot', interpolation='bilinear',\n                   origin='lower', vmin=vmin, vmax=vmax, \n                   extent=[0, 1, 0, 1])\n\n    # Barra de color\n    cbar = plt.colorbar(im, ax=ax, label='Temperatura')\n\n    # Funci\u00f3n de actualizaci\u00f3n\n    def actualizar(frame):\n        im.set_array(soluciones[frame])\n        # Actualizar informaci\u00f3n de tiempo y temperatura\n        # ...\n        return [im]\n\n    anim = FuncAnimation(fig, actualizar, frames=len(soluciones),\n                        interval=intervalo, blit=True, repeat=True)\n\n    return anim\n</code></pre> <p>Pr\u00f3ximo paso: Revisa Ejemplos de Uso para casos pr\u00e1cticos completos.</p>"},{"location":"matematica/condiciones/","title":"Condiciones de Frontera","text":""},{"location":"matematica/condiciones/#tipos-de-condiciones","title":"Tipos de Condiciones","text":""},{"location":"matematica/condiciones/#1-condiciones-de-dirichlet","title":"1. Condiciones de Dirichlet","text":""},{"location":"matematica/condiciones/#implementacion-numerica","title":"Implementaci\u00f3n Num\u00e9rica","text":"<p>Para una frontera izquierda con temperatura \\(g\\):</p> \\[ u_{0,j}^{n+1} = g(y_j, t_{n+1}) \\] <p>Este es un valor conocido, por lo que se mueve al lado derecho del sistema:</p> <pre><code># Punto interior m\u00e1s cercano a la frontera izquierda\nidx = j * N + 0  # i = 0\n\n# T\u00e9rmino que se a\u00f1ade al RHS\nb[idx] += mu_x * g_left(y_j, t_n)\n</code></pre> <p>La logica es la misma los otros bordes.</p>"},{"location":"matematica/condiciones/#2-condiciones-de-neumann","title":"2. Condiciones de Neumann","text":""},{"location":"matematica/condiciones/#implementacion-numerica-con-puntos-fantasma","title":"Implementaci\u00f3n num\u00e9rica con Puntos Fantasma","text":"<p>Para implementar condiciones de Neumann, introducimos puntos fantasma fuera del dominio.</p>"},{"location":"matematica/condiciones/#frontera-izquierda-x-0","title":"Frontera Izquierda (\\(x = 0\\))","text":"<p>La condici\u00f3n de Neumann es:</p> \\[ \\frac{\\partial u}{\\partial x}\\bigg|_{x=0} = g(y, t) \\] <p>Se aproxima esta derivada por diferencias centrales:</p> \\[ \\frac{u_{1,j} - u_{-1,j}}{2h_x} = g(y_j, t) \\] <p>donde \\(u_{-1,j}\\) es el punto fantasma.</p> <p>Se despeja este punto fantasma::</p> \\[ u_{-1,j} = u_{1,j} - 2h_x \\cdot g(y_j, t) \\] <p>Se sustituye en la aproximaci\u00f3n de la segunda derivada:</p> \\[ \\begin{align} \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{0,j} &amp;\\approx \\frac{u_{-1,j} - 2u_{0,j} + u_{1,j}}{h_x^2} \\\\ &amp;= \\frac{(u_{1,j} - 2h_x g) - 2u_{0,j} + u_{1,j}}{h_x^2} \\\\ &amp;= \\frac{2u_{1,j} - 2u_{0,j}}{h_x^2} - \\frac{2g}{h_x} \\end{align} \\]"},{"location":"matematica/condiciones/#modificaciones-al-sistema-lineal","title":"Modificaciones al Sistema Lineal","text":"<p>Como se puede ver, los resultados anteriores modifican el planteamiento del sistema lineal que obtuvimos en la derivacion anterior:</p>"},{"location":"matematica/condiciones/#en-la-matriz-a","title":"En la Matriz \\(A\\)","text":"<p>El coeficiente del vecino en la direcci\u00f3n de la frontera se duplica:</p> <p>Antes (Dirichlet o punto interior): <pre><code>A[idx, idx]     =  1 + 2\u03bc\u2093 + 2\u03bc\u1d67\nA[idx, idx+1]   = -\u03bc\u2093           (vecino derecho)\n</code></pre></p> <p>Ahora (Neumann izquierda): <pre><code>A[idx, idx]     =  1 + 2\u03bc\u2093 + 2\u03bc\u1d67\nA[idx, idx+1]   = -2\u03bc\u2093          (coeficiente duplicado)\n</code></pre></p>"},{"location":"matematica/condiciones/#en-el-vector-b-rhs","title":"En el Vector \\(b\\) (RHS)","text":"<p>Se a\u00f1ade el t\u00e9rmino del flujo:</p> <pre><code>b[idx] -= 2 * mu_x * h_x * g(y_j, t_n)\n</code></pre> <p>Signo: Depende de la orientaci\u00f3n de la normal exterior: - Frontera izquierda: \\(-2\\mu_x h_x g\\) - Frontera derecha: \\(+2\\mu_x h_x g\\) - Frontera inferior: \\(-2\\mu_y h_y g\\) - Frontera superior: \\(+2\\mu_y h_y g\\)</p>"},{"location":"matematica/condiciones/#tabla-de-modificaciones","title":"Tabla de Modificaciones","text":"<p>Se presenta la siguiente tabla a modo de resumen:</p> Frontera Normal Coeficiente duplicado T\u00e9rmino RHS Izquierda (\\(x=0\\)) \\(-\\hat{x}\\) \\(A[idx, idx+1] = -2\\mu_x\\) \\(-2\\mu_x h_x g\\) Derecha (\\(x=a\\)) \\(+\\hat{x}\\) \\(A[idx, idx-1] = -2\\mu_x\\) \\(+2\\mu_x h_x g\\) Inferior (\\(y=0\\)) \\(-\\hat{y}\\) \\(A[idx, idx+N] = -2\\mu_y\\) \\(-2\\mu_y h_y g\\) Superior (\\(y=b\\)) \\(+\\hat{y}\\) \\(A[idx, idx-N] = -2\\mu_y\\) \\(+2\\mu_y h_y g\\) <p>Ahora: En la secci\u00f3n Python se puede ver c\u00f3mo se implemento la solucion en Python.</p>"},{"location":"matematica/formulacion/","title":"Formulaci\u00f3n Matem\u00e1tica","text":""},{"location":"matematica/formulacion/#la-ecuacion-de-calor","title":"La Ecuaci\u00f3n de Calor","text":"<p>La ecuaci\u00f3n de calor en dos dimensiones es una ecuaci\u00f3n diferencial parcial parab\u00f3lica que describe la distribuci\u00f3n de temperatura en una regi\u00f3n espacial a lo largo del tiempo.</p>"},{"location":"matematica/formulacion/#ecuacion-diferencial","title":"Ecuaci\u00f3n Diferencial","text":"<p>La forma general de la ecuaci\u00f3n de calor en 2D es:</p> \\[ \\frac{\\partial u}{\\partial t} = c^2 \\left[\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\\right]  \\] <p>donde:</p> <ul> <li>\\(u(x, y, t)\\): temperatura en el punto \\((x, y)\\) en el tiempo \\(t\\)</li> <li>\\(c^2\\): coeficiente de difusi\u00f3n t\u00e9rmica</li> </ul>"},{"location":"matematica/formulacion/#dominio-y-condiciones","title":"Dominio y Condiciones","text":"<p>El problema se define en un dominio rectangular:</p> \\[ D = [0, a] \\times [0, b] \\subset \\mathbb{R}^2 \\] <p>en un intervalo temporal:</p> \\[ t \\in [0, T] \\]"},{"location":"matematica/formulacion/#condiciones-iniciales","title":"Condiciones Iniciales","text":"<p>La distribuci\u00f3n de temperatura en \\(t = 0\\) debe especificarse:</p> \\[ u(x, y, 0) = u_0(x, y) \\quad \\forall (x, y) \\in D \\] <p>Esta funci\u00f3n \\(u_0(x, y)\\) determina c\u00f3mo comienza el proceso de difusi\u00f3n t\u00e9rmica.</p>"},{"location":"matematica/formulacion/#condiciones-de-frontera","title":"Condiciones de Frontera","text":"<p>Las condiciones de frontera describen c\u00f3mo interact\u00faa la regi\u00f3n con su entorno. Se implementaron dos tipos principales:</p>"},{"location":"matematica/formulacion/#condiciones-de-dirichlet","title":"Condiciones de Dirichlet","text":"<p>Describen una temperatura constante en la frontera:</p> \\[ u(x, y, t) = g(x, y, t) \\quad \\text{en } \\partial D \\] <p>Interpretaci\u00f3n f\u00edsica: La frontera se mantiene a una temperatura conocida y constante.</p>"},{"location":"matematica/formulacion/#condiciones-de-neumann","title":"Condiciones de Neumann","text":"<p>Especifican el flujo de calor en la frontera:</p> \\[ \\frac{\\partial u}{\\partial n} = g(x, y, t) \\quad \\text{en } \\partial D \\] <p>Interpretaci\u00f3n f\u00edsica: Se prescribe el flujo t\u00e9rmico a trav\u00e9s de la frontera:</p> <ul> <li>Si g &gt; 0: el calor entra.</li> <li>Si g &lt; 0: el calor sale.</li> <li>Si g = 0: el sistema es aislado.</li> </ul> <p>Ahora: En la secci\u00f3n Metodolog\u00eda Num\u00e9rica se puede ver c\u00f3mo discretizamos y resolvemos esta ecuaci\u00f3n num\u00e9ricamente.</p>"},{"location":"matematica/metodologia/","title":"Metodolog\u00eda Num\u00e9rica","text":""},{"location":"matematica/metodologia/#esquema-de-euler-implicito","title":"Esquema de Euler Impl\u00edcito","text":"<p>Para resolver la ecuaci\u00f3n de calor num\u00e9ricamente, utilizamos el m\u00e9todo de diferencias finitas con el esquema de Euler Impl\u00edcito.</p>"},{"location":"matematica/metodologia/#discretizacion-del-dominio","title":"Discretizaci\u00f3n del Dominio","text":""},{"location":"matematica/metodologia/#malla-espacial","title":"Malla Espacial","text":"<p>Dividimos el dominio \\([0, a] \\times [0, b]\\) en una malla uniforme de \\(N \\times N\\) nodos interiores. Se definen los siguientes pasos espaciales:</p> \\[ \\begin{align} h_x = \\frac{a}{N+1} \\\\ h_y = \\frac{b}{N+1} \\end{align} \\]"},{"location":"matematica/metodologia/#malla-temporal","title":"Malla Temporal","text":"<p>El intervalo temporal \\([0, T]\\) se divide en \\(M\\) pasos donde \\(k = \\frac{T}{M}\\) es el paso temporal.</p>"},{"location":"matematica/metodologia/#aproximacion-por-diferencias-finitas","title":"Aproximaci\u00f3n por Diferencias Finitas","text":""},{"location":"matematica/metodologia/#derivadas-espaciales-diferencias-centrales","title":"Derivadas Espaciales (Diferencias Centrales)","text":"<p>Para las segundas derivadas espaciales usamos diferencias centrales de segundo orden:</p> \\[ \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{i,j} \\approx \\frac{u_{i-1,j} - 2u_{i,j} + u_{i+1,j}}{h_x^2} \\] \\[ \\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{i,j} \\approx \\frac{u_{i,j-1} - 2u_{i,j} + u_{i,j+1}}{h_y^2} \\] <p>Error de truncamiento: \\(\\mathcal{O}(h^2)\\)</p>"},{"location":"matematica/metodologia/#derivada-temporal-diferencias-hacia-adelante","title":"Derivada Temporal (Diferencias hacia adelante)","text":"<p>Se aproxima la derivada temporal haciendo diferencias hacia adelante:</p> \\[ \\frac{\\partial u}{\\partial t}\\bigg|_{i,j}^{n} \\approx \\frac{u_{i,j}^{n+1} - u_{i,j}^n}{k} \\]"},{"location":"matematica/metodologia/#esquema-numerico-completo","title":"Esquema Num\u00e9rico Completo","text":""},{"location":"matematica/metodologia/#ecuacion-discretizada","title":"Ecuaci\u00f3n Discretizada","text":"<p>Se sustituyen las aproximaciones anteriores en la ecuacion de calor:</p> \\[ \\frac{u_{i,j}^{n+1} - u_{i,j}^n}{k} = c^2 \\left[\\frac{u_{i-1,j}^{n+1} - 2u_{i,j}^{n+1} + u_{i+1,j}^{n+1}}{h_x^2} + \\frac{u_{i,j-1}^{n+1} - 2u_{i,j}^{n+1} + u_{i,j+1}^{n+1}}{h_y^2}\\right] \\] <p>De lo anterior, se puede definir:</p> \\[ \\mu_x = \\frac{c^2 k}{h_x^2}, \\quad \\mu_y = \\frac{c^2 k}{h_y^2} \\] <p>Reordenando queda:</p> \\[ (1 + 2\\mu_x + 2\\mu_y)u_{i,j}^{n+1} - \\mu_x(u_{i-1,j}^{n+1} + u_{i+1,j}^{n+1}) - \\mu_y(u_{i,j-1}^{n+1} + u_{i,j+1}^{n+1}) = u_{i,j}^n \\] <p>donde el lado derecho (RHS) contiene solo t\u00e9rminos conocidos en el tiempo \\(t_n\\).</p>"},{"location":"matematica/metodologia/#sistema-lineal","title":"Sistema Lineal","text":""},{"location":"matematica/metodologia/#estructura-matricial","title":"Estructura Matricial","text":"<p>El sistema completo obtenido anteriormente se puede escribir como:</p> \\[ A \\mathbf{u}^{n+1} = \\mathbf{b}^n \\] <p>donde:</p> <ul> <li>\\(A\\): matriz de coeficientes.</li> <li>\\(\\mathbf{u}^{n+1}\\): vector de inc\u00f3gnitas en el tiempo \\(t_{n+1}\\).</li> <li>\\(\\mathbf{b}^n\\): vector del lado derecho (conocido).</li> </ul>"},{"location":"matematica/metodologia/#ordenamiento-de-incognitas","title":"Ordenamiento de Inc\u00f3gnitas","text":"<p>Se ordenan las incognitas de la siguiente manera:</p> \\[ \\mathbf{u^{n+1}} = [u_{1,1}, u_{2,1}, \\ldots, u_{N_x,1}, u_{1,2}, u_{2,2}, \\ldots, u_{N_x,2}, \\ldots, u_{N_x,N_y}]^T \\] <p>Este ordenamiento resulta en una matriz \\(A\\) de dimensi\u00f3n \\((N \\times N) \\times (N \\times N)\\).</p>"},{"location":"matematica/metodologia/#estructura-de-la-matriz-a","title":"Estructura de la Matriz \\(A\\)","text":"<p>De lo obtenido anteriormente, podemos ver que para un punto \\((i,j)\\) dentro de la malla, su ecuacion tambien involucra a sus vecinos horizontales y verticales, donde podemos ver que sus coeficientes se ven de la siguiente manera:</p> <ul> <li>\\(u^{n+1}_{i,j}: 1 + 2\\mu_x + 2\\mu_y\\)</li> <li>\\({u}^{n+1}_{i\\pm1,j}:-\\mu_x\\)</li> <li>\\({u}^{n+1}_{i,j\\pm1}:-\\mu_x\\)</li> </ul> <p>Entonces, \\(A\\) es una matriz tridiagonal por bloques con la siguiente estructura:</p>"},{"location":"matematica/metodologia/#bloque-diagonal-b","title":"Bloque diagonal B","text":"<p>Corresponden a los nodos de una misma fila, donde su diagonal principal es \\(1 + 2\\mu_x + 2\\mu_y\\) y subdiagonal y superdiagonal es \\(-\\mu_x\\). Es decir: \\(B= tridiagonal(-\\mu_x, 1 + 2\\mu_x + 2\\mu_y, -\\mu_x)\\)</p>"},{"location":"matematica/metodologia/#bloques-fuera-de-la-diagonal","title":"Bloques fuera de la diagonal","text":"<p>Son los que conectan filas adyacentes, o sea \\(j\\) y \\(j\\pm1\\). Entonces cada nodo \\((i,j)\\) se conecta solo con nodos de la misma columna pero diferente fila. Por lo tanto, estos bloques estan compuestos por matrices diagonales con \\(-\\mu_y\\) en la diagonal, es decir, \\(C=-\\mu_y I\\)</p> <p>Entonces, la matriz A tiene la siguiente forma:</p> \\[ A= \\begin{bmatrix}     B &amp; C &amp; 0 &amp; \\ldots &amp; 0 \\\\ C &amp; B &amp; C &amp; \\ldots &amp; 0 \\\\ 0 &amp; C &amp; B &amp; \\ddots &amp; \\vdots \\\\ \\vdots &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp; C \\\\     0 &amp; \\ldots &amp; 0 &amp; C &amp; B     \\end{bmatrix}     \\] <p>Esta es una matriz dispersa que se puede almacenar y resolver eficientemente.</p> <p>Ahora: En la secci\u00f3n Condiciones de Frontera se puede ver c\u00f3mo se manejan las condiciones de frontera (Dirichlet y Neumann) numericamente.</p>"}]}