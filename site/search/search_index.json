{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Ecuaci\u00f3n de Calor en Dos Dimensiones","text":""},{"location":"#bienvenido","title":"Bienvenido","text":"<p>Este proyecto presenta una soluci\u00f3n num\u00e9rica completa para la ecuaci\u00f3n de calor en dos dimensiones, implementando m\u00e9todos de diferencias finitas con el esquema de Euler Impl\u00edcito.</p>"},{"location":"#vision-general-del-proyecto","title":"Visi\u00f3n General del Proyecto","text":"<p>La ecuaci\u00f3n de calor describe c\u00f3mo se distribuye la temperatura en una regi\u00f3n a lo largo del tiempo. En este proyecto, resolvemos:</p> \\[ \\frac{\\partial u}{\\partial t} = c^2 \\left[\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\\right] \\] <p>donde:</p> <ul> <li>\\(u = u(x, y, t)\\): temperatura en el punto \\((x, y)\\) en el tiempo \\(t\\)</li> <li>\\(c\\): coeficiente de difusi\u00f3n t\u00e9rmica</li> <li>\\(x \\in [0, a]\\), \\(y \\in [0, b]\\): regi\u00f3n espacial bidimensional</li> </ul>"},{"location":"#caracteristicas-del-proyecto","title":"Caracter\u00edsticas del proyecto","text":"<ul> <li>Implementaci\u00f3n en Python</li> <li>Animaci\u00f3n de la evoluci\u00f3n temporal para diversas condiciones iniciales y de fronter</li> <li>Implementaci\u00f3n en C++</li> <li>Aceleraci\u00f3n de la implementaci\u00f3n mediante paralelismo de memoria compartida</li> </ul>"},{"location":"referencias/","title":"Referencias","text":"<p>Saad, Y. (2003). Iterative methods for sparse linear systems (2nd ed.). Society for Industrial and Applied Mathematics.</p> <p>MIT. (s.f.). 6.338J / 18.366J: Parallel scientific computing. Massachusetts Institute of Technology. Disponible en: https://ocw.mit.edu</p> <p>LeVeque, R. J. (2007). Finite difference methods for ordinary and partial differential equations: Steady-state and time-dependent problems. Society for Industrial and Applied Mathematics.</p> <p>Brunet, P., &amp; Van Hentenryck, P. (2012). Red-black ordering and parallel graph coloring strategies for PDE solvers. INFORMS Journal on Computing, 24(3), 435\u2013451.  </p> <p>Sequeira-Chavarr\u00eda, F., &amp; Ram\u00edrez-Bogantes, M. (2019). Aspectos computacionales del m\u00e9todo de diferencias finitas para la ecuaci\u00f3n de calor dependiente del tiempo. Uniciencia, 33(1), 1\u201322. </p>"},{"location":"ejemplos/casos-prueba/","title":"Casos de Prueba","text":"<p>Esta secci\u00f3n presenta casos de prueba completos que combinan diferentes condiciones iniciales y de frontera para ilustrar diversos comportamientos f\u00edsicos.</p>"},{"location":"ejemplos/casos-prueba/#caso-1-enfriamiento-total","title":"Caso 1: Enfriamiento Total","text":""},{"location":"ejemplos/casos-prueba/#descripcion","title":"Descripci\u00f3n","text":"<p>Una regi\u00f3n inicialmente caliente que se enfr\u00eda completamente debido a fronteras fr\u00edas.</p>"},{"location":"ejemplos/casos-prueba/#configuracion","title":"Configuraci\u00f3n","text":"<pre><code>from heat_equation_2d import HeatEquation2D, DistribucionGaussiana\n\n# Todas las fronteras a temperatura 0\ncondiciones = {\n    'left':   {'type': 'dirichlet', 'valor': 0.0},\n    'right':  {'type': 'dirichlet', 'valor': 0.0},\n    'bottom': {'type': 'dirichlet', 'valor': 0.0},\n    'top':    {'type': 'dirichlet', 'valor': 0.0}\n}\n\nsolver = HeatEquation2D(\n    N=150,\n    M=300,\n    T=1.0,\n    condiciones_frontera=condiciones\n)\n\nsoluciones, tiempos = solver.solve(DistribucionGaussiana, save_every=10)\n</code></pre>"},{"location":"ejemplos/casos-prueba/#resultados-esperados","title":"Resultados Esperados","text":"Tiempo Temperatura M\u00e1xima Observaci\u00f3n t=0.0 100.0\u00b0C Pico inicial t=0.2 ~60\u00b0C Disminuci\u00f3n r\u00e1pida t=0.5 ~20\u00b0C Cerca de las fronteras t=1.0 ~5\u00b0C Casi completamente fr\u00edo"},{"location":"ejemplos/casos-prueba/#analisis","title":"An\u00e1lisis","text":"<ul> <li>El calor fluye hacia las fronteras y se disipa</li> <li>La temperatura m\u00e1xima decrece exponencialmente</li> <li>En \\(t \\to \\infty\\), toda la regi\u00f3n alcanza 0\u00b0C</li> </ul> <p>Conservaci\u00f3n de energ\u00eda</p> <p>La energ\u00eda total del sistema disminuye porque se transfiere al exterior a trav\u00e9s de las fronteras.</p>"},{"location":"ejemplos/casos-prueba/#caso-2-redistribucion-con-aislamiento","title":"Caso 2: Redistribuci\u00f3n con Aislamiento","text":""},{"location":"ejemplos/casos-prueba/#descripcion_1","title":"Descripci\u00f3n","text":"<p>Una regi\u00f3n con distribuci\u00f3n no uniforme de calor que se redistribuye sin p\u00e9rdida de energ\u00eda total.</p>"},{"location":"ejemplos/casos-prueba/#configuracion_1","title":"Configuraci\u00f3n","text":"<pre><code>from heat_equation_2d import HeatEquation2D, CuatroEsquinas\n\n# Todas las fronteras aisladas\ncondiciones = {\n    'left':   {'type': 'neumann', 'valor': 0.0},\n    'right':  {'type': 'neumann', 'valor': 0.0},\n    'bottom': {'type': 'neumann', 'valor': 0.0},\n    'top':    {'type': 'neumann', 'valor': 0.0}\n}\n\nsolver = HeatEquation2D(\n    N=150,\n    M=400,\n    T=1.5,\n    condiciones_frontera=condiciones\n)\n\nsoluciones, tiempos = solver.solve(CuatroEsquinas, save_every=10)\n</code></pre>"},{"location":"ejemplos/casos-prueba/#resultados-esperados_1","title":"Resultados Esperados","text":"Tiempo Temp. M\u00e1xima Temp. M\u00ednima Temp. Promedio t=0.0 100\u00b0C 0\u00b0C ~25\u00b0C t=0.3 ~75\u00b0C ~10\u00b0C ~25\u00b0C t=0.8 ~35\u00b0C ~20\u00b0C ~25\u00b0C t=1.5 ~27\u00b0C ~23\u00b0C ~25\u00b0C"},{"location":"ejemplos/casos-prueba/#analisis_1","title":"An\u00e1lisis","text":"<ul> <li>El calor se redistribuye uniformemente</li> <li>No hay p\u00e9rdida de energ\u00eda (fronteras aisladas)</li> <li>La temperatura promedio se conserva exactamente</li> <li>En \\(t \\to \\infty\\), la temperatura es uniforme en todo el dominio</li> </ul>"},{"location":"ejemplos/casos-prueba/#verificacion-de-conservacion","title":"Verificaci\u00f3n de Conservaci\u00f3n","text":"<pre><code># Calcular energ\u00eda total en cada tiempo\nh = solver.hx * solver.hy\nenergias = [np.sum(sol) * h for sol in soluciones]\n\nprint(\"Energ\u00eda total en cada tiempo:\")\nfor t, E in zip(tiempos, energias):\n    print(f\"  t={t:.3f}: E={E:.6f}\")\n\nprint(f\"\\nVariaci\u00f3n m\u00e1xima: {np.ptp(energias):.8f}\")\n</code></pre> <p>Resultado esperado: Variaci\u00f3n \\(&lt; 10^{-6}\\)</p>"},{"location":"ejemplos/casos-prueba/#caso-3-flujo-constante-por-una-frontera","title":"Caso 3: Flujo Constante por una Frontera","text":""},{"location":"ejemplos/casos-prueba/#descripcion_2","title":"Descripci\u00f3n","text":"<p>Una regi\u00f3n donde entra calor constantemente por una frontera mientras otras permanecen fr\u00edas.</p>"},{"location":"ejemplos/casos-prueba/#configuracion_2","title":"Configuraci\u00f3n","text":"<pre><code>from heat_equation_2d import HeatEquation2D\n\ndef InicialCero(x, y):\n    \"\"\"Regi\u00f3n inicialmente fr\u00eda\"\"\"\n    return 0.0\n\n# Flujo de calor por la izquierda, otras fronteras fr\u00edas\ncondiciones = {\n    'left':   {'type': 'neumann', 'valor': 10.0},  # Flujo entrante\n    'right':  {'type': 'dirichlet', 'valor': 0.0},\n    'bottom': {'type': 'dirichlet', 'valor': 0.0},\n    'top':    {'type': 'dirichlet', 'valor': 0.0}\n}\n\nsolver = HeatEquation2D(\n    N=150,\n    M=500,\n    T=2.0,\n    condiciones_frontera=condiciones\n)\n\nsoluciones, tiempos = solver.solve(InicialCero, save_every=10)\n</code></pre>"},{"location":"ejemplos/casos-prueba/#resultados-esperados_2","title":"Resultados Esperados","text":"<ul> <li>Inicialmente: Regi\u00f3n completamente fr\u00eda</li> <li>t \u2248 0.2: Calentamiento cerca de la frontera izquierda</li> <li>t \u2248 0.8: Gradiente de temperatura establecido</li> <li>t \u2192 \u221e: Estado estacionario con gradiente lineal</li> </ul>"},{"location":"ejemplos/casos-prueba/#estado-estacionario","title":"Estado Estacionario","text":"<p>En equilibrio (\\(\\frac{\\partial u}{\\partial t} = 0\\)), la soluci\u00f3n satisface:</p> \\[ \\nabla^2 u = 0 \\quad \\text{(Ecuaci\u00f3n de Laplace)} \\] <p>Con las condiciones dadas, se espera un gradiente aproximadamente lineal desde la frontera izquierda hacia las otras fronteras.</p>"},{"location":"ejemplos/casos-prueba/#caso-4-condiciones-mixtas-asimetricas","title":"Caso 4: Condiciones Mixtas Asim\u00e9tricas","text":""},{"location":"ejemplos/casos-prueba/#descripcion_3","title":"Descripci\u00f3n","text":"<p>Combinaci\u00f3n de diferentes tipos de condiciones en cada frontera para crear patrones de flujo complejos.</p>"},{"location":"ejemplos/casos-prueba/#configuracion_3","title":"Configuraci\u00f3n","text":"<pre><code>from heat_equation_2d import HeatEquation2D, Anillo\n\n# Frontera izquierda caliente, derecha fr\u00eda, superior/inferior aisladas\ncondiciones = {\n    'left':   {'type': 'dirichlet', 'valor': 80.0},   # Caliente\n    'right':  {'type': 'dirichlet', 'valor': 20.0},   # Fr\u00eda\n    'bottom': {'type': 'neumann', 'valor': 0.0},      # Aislada\n    'top':    {'type': 'neumann', 'valor': 0.0}       # Aislada\n}\n\nsolver = HeatEquation2D(\n    N=150,\n    M=400,\n    T=1.0,\n    condiciones_frontera=condiciones\n)\n\nsoluciones, tiempos = solver.solve(Anillo, save_every=10)\n</code></pre>"},{"location":"ejemplos/casos-prueba/#resultados-esperados_3","title":"Resultados Esperados","text":"<ul> <li>Flujo dominante: De izquierda (caliente) a derecha (fr\u00eda)</li> <li>Fronteras superior/inferior: No afectan el flujo (aisladas)</li> <li>Patr\u00f3n final: Gradiente aproximadamente horizontal</li> </ul>"},{"location":"ejemplos/casos-prueba/#analisis-del-flujo","title":"An\u00e1lisis del Flujo","text":"<pre><code># Calcular flujo de calor en direcci\u00f3n x\ndef calcular_flujo_x(sol, hx):\n    \"\"\"Calcula \u2202u/\u2202x usando diferencias centrales\"\"\"\n    flujo = np.zeros_like(sol)\n    flujo[:, 1:-1] = (sol[:, 2:] - sol[:, :-2]) / (2 * hx)\n    return flujo\n\n# Para \u00faltima soluci\u00f3n\nflujo_x = calcular_flujo_x(soluciones[-1], solver.hx)\nprint(f\"Flujo promedio en x: {np.mean(flujo_x):.4f}\")\n</code></pre>"},{"location":"ejemplos/casos-prueba/#caso-5-calentamiento-periodico","title":"Caso 5: Calentamiento Peri\u00f3dico","text":""},{"location":"ejemplos/casos-prueba/#descripcion_4","title":"Descripci\u00f3n","text":"<p>Una frontera con temperatura que oscila peri\u00f3dicamente en el tiempo.</p>"},{"location":"ejemplos/casos-prueba/#configuracion_4","title":"Configuraci\u00f3n","text":"<pre><code>from heat_equation_2d import HeatEquation2D, DistribucionGaussiana\nimport numpy as np\n\n# Frontera izquierda con temperatura oscilante\ndef temp_oscilante(t, pos):\n    \"\"\"Temperatura que oscila sinusoidalmente\"\"\"\n    T_media = 50.0\n    amplitud = 30.0\n    periodo = 0.5\n    return T_media + amplitud * np.sin(2 * np.pi * t / periodo)\n\ncondiciones = {\n    'left':   {'type': 'dirichlet', 'valor': temp_oscilante},\n    'right':  {'type': 'dirichlet', 'valor': 0.0},\n    'bottom': {'type': 'neumann', 'valor': 0.0},\n    'top':    {'type': 'neumann', 'valor': 0.0}\n}\n\nsolver = HeatEquation2D(\n    N=150,\n    M=600,\n    T=3.0,  # Simular varios periodos\n    condiciones_frontera=condiciones\n)\n\nsoluciones, tiempos = solver.solve(DistribucionGaussiana, save_every=10)\n</code></pre>"},{"location":"ejemplos/casos-prueba/#resultados-esperados_4","title":"Resultados Esperados","text":"<ul> <li>Onda t\u00e9rmica propag\u00e1ndose desde la frontera izquierda</li> <li>Atenuaci\u00f3n: La amplitud de la oscilaci\u00f3n disminuye con la distancia</li> <li>Desfase: La oscilaci\u00f3n se retrasa a medida que nos alejamos de la frontera</li> </ul>"},{"location":"ejemplos/casos-prueba/#analisis-de-temperatura-en-puntos-especificos","title":"An\u00e1lisis de Temperatura en Puntos Espec\u00edficos","text":"<pre><code># Extraer temperatura en x = 0.25 (cerca de frontera) y x = 0.75 (lejos)\nidx_cerca = int(0.25 * solver.N)\nidx_lejos = int(0.75 * solver.N)\nj_medio = solver.N // 2\n\ntemp_cerca = [sol[j_medio, idx_cerca] for sol in soluciones]\ntemp_lejos = [sol[j_medio, idx_lejos] for sol in soluciones]\n\nplt.figure(figsize=(10, 6))\nplt.plot(tiempos, temp_cerca, label='x=0.25 (cerca)', linewidth=2)\nplt.plot(tiempos, temp_lejos, label='x=0.75 (lejos)', linewidth=2)\nplt.xlabel('Tiempo')\nplt.ylabel('Temperatura')\nplt.title('Respuesta a calentamiento peri\u00f3dico')\nplt.legend()\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"ejemplos/casos-prueba/#caso-6-test-de-convergencia","title":"Caso 6: Test de Convergencia","text":""},{"location":"ejemplos/casos-prueba/#descripcion_5","title":"Descripci\u00f3n","text":"<p>Verificar que la soluci\u00f3n converge al refinar la malla espacial y temporal.</p>"},{"location":"ejemplos/casos-prueba/#configuracion_5","title":"Configuraci\u00f3n","text":"<pre><code>from heat_equation_2d import HeatEquation2D, DistribucionGaussiana\n\ncondiciones = {\n    'left':   {'type': 'dirichlet', 'valor': 0.0},\n    'right':  {'type': 'dirichlet', 'valor': 0.0},\n    'bottom': {'type': 'dirichlet', 'valor': 0.0},\n    'top':    {'type': 'dirichlet', 'valor': 0.0}\n}\n\n# Resolver con diferentes resoluciones\nresoluciones = [\n    (50, 100),    # Grueso\n    (100, 200),   # Medio\n    (150, 300),   # Fino\n    (200, 400)    # Muy fino\n]\n\nsoluciones_finales = []\n\nfor N, M in resoluciones:\n    solver = HeatEquation2D(\n        N=N, M=M, T=0.5,\n        condiciones_frontera=condiciones\n    )\n    sols, _ = solver.solve(DistribucionGaussiana)\n    soluciones_finales.append(sols[-1])\n    print(f\"N={N}, M={M}: Temp. m\u00e1x. final = {sols[-1].max():.6f}\")\n</code></pre>"},{"location":"ejemplos/casos-prueba/#analisis-de-convergencia","title":"An\u00e1lisis de Convergencia","text":"<pre><code># Calcular diferencia entre soluciones sucesivas\nfor i in range(1, len(soluciones_finales)):\n    # Interpolar soluci\u00f3n gruesa a malla fina para comparaci\u00f3n\n    sol_gruesa = soluciones_finales[i-1]\n    sol_fina = soluciones_finales[i]\n\n    # Diferencia relativa (simplificada)\n    diff = abs(sol_fina.max() - sol_gruesa.max()) / sol_fina.max()\n    print(f\"Diferencia {i-1}\u2192{i}: {diff:.6f} ({diff*100:.3f}%)\")\n</code></pre> <p>Resultado esperado: Las diferencias deben disminuir al refinar la malla, confirmando convergencia.</p>"},{"location":"ejemplos/casos-prueba/#caso-7-simetria","title":"Caso 7: Simetr\u00eda","text":""},{"location":"ejemplos/casos-prueba/#descripcion_6","title":"Descripci\u00f3n","text":"<p>Verificar que condiciones sim\u00e9tricas producen soluciones sim\u00e9tricas.</p>"},{"location":"ejemplos/casos-prueba/#configuracion_6","title":"Configuraci\u00f3n","text":"<pre><code>from heat_equation_2d import HeatEquation2D, DistribucionGaussiana\n\n# Condiciones completamente sim\u00e9tricas\ncondiciones = {\n    'left':   {'type': 'neumann', 'valor': 0.0},\n    'right':  {'type': 'neumann', 'valor': 0.0},\n    'bottom': {'type': 'neumann', 'valor': 0.0},\n    'top':    {'type': 'neumann', 'valor': 0.0}\n}\n\nsolver = HeatEquation2D(\n    N=150, M=200, T=0.5,\n    condiciones_frontera=condiciones\n)\n\nsoluciones, tiempos = solver.solve(DistribucionGaussiana)\n</code></pre>"},{"location":"ejemplos/casos-prueba/#verificacion-de-simetria","title":"Verificaci\u00f3n de Simetr\u00eda","text":"<pre><code># La soluci\u00f3n debe ser sim\u00e9trica respecto a x=0.5 e y=0.5\nsol_final = soluciones[-1]\nN = sol_final.shape[0]\n\n# Simetr\u00eda en x\ndiff_x = np.abs(sol_final - np.fliplr(sol_final))\nprint(f\"Error de simetr\u00eda en x: {diff_x.max():.8f}\")\n\n# Simetr\u00eda en y\ndiff_y = np.abs(sol_final - np.flipud(sol_final))\nprint(f\"Error de simetr\u00eda en y: {diff_y.max():.8f}\")\n</code></pre> <p>Resultado esperado: Errores \\(&lt; 10^{-10}\\) (errores de redondeo num\u00e9rico)</p>"},{"location":"ejemplos/casos-prueba/#resumen-de-casos-de-prueba","title":"Resumen de Casos de Prueba","text":"Caso Condiciones Iniciales Fronteras Comportamiento Clave 1. Enfriamiento Gaussiana Dirichlet (T=0) Temperatura \u2192 0 2. Redistribuci\u00f3n Cuatro Esquinas Neumann (aislado) Energ\u00eda conservada 3. Flujo Constante Cero Neumann (flujo) + Dirichlet Estado estacionario 4. Mixtas Anillo Mixtas asim\u00e9tricas Flujo direccional 5. Peri\u00f3dico Gaussiana Dirichlet oscilante Onda t\u00e9rmica 6. Convergencia Gaussiana Dirichlet Verificaci\u00f3n num\u00e9rica 7. Simetr\u00eda Gaussiana Neumann sim\u00e9trico Simetr\u00eda preservada"},{"location":"ejemplos/casos-prueba/#script-de-prueba-automatizado","title":"Script de Prueba Automatizado","text":"<pre><code>def ejecutar_casos_prueba():\n    \"\"\"Ejecuta todos los casos de prueba y genera reporte\"\"\"\n\n    casos = [\n        (\"Enfriamiento\", caso1_enfriamiento),\n        (\"Redistribuci\u00f3n\", caso2_redistribucion),\n        (\"Flujo constante\", caso3_flujo_constante),\n        (\"Mixtas\", caso4_mixtas),\n        (\"Peri\u00f3dico\", caso5_periodico),\n        (\"Convergencia\", caso6_convergencia),\n        (\"Simetr\u00eda\", caso7_simetria)\n    ]\n\n    resultados = []\n\n    for nombre, funcion_caso in casos:\n        print(f\"\\n{'='*60}\")\n        print(f\"Ejecutando: {nombre}\")\n        print('='*60)\n\n        try:\n            resultado = funcion_caso()\n            resultados.append((nombre, \"\u2713 Exitoso\", resultado))\n            print(f\"\u2713 {nombre} completado exitosamente\")\n        except Exception as e:\n            resultados.append((nombre, \"\u2717 Fall\u00f3\", str(e)))\n            print(f\"\u2717 {nombre} fall\u00f3: {e}\")\n\n    # Generar reporte\n    print(\"\\n\" + \"=\"*60)\n    print(\"RESUMEN DE PRUEBAS\")\n    print(\"=\"*60)\n    for nombre, estado, info in resultados:\n        print(f\"{estado} {nombre}\")\n\n    return resultados\n\n# Ejecutar todas las pruebas\nresultados = ejecutar_casos_prueba()\n</code></pre>"},{"location":"ejemplos/ejemplos-ejecucion/","title":"Ejecuci\u00f3n y Resultados","text":""},{"location":"ejemplos/ejemplos-ejecucion/#ejemplo-1-python-condicion-inicial-diagonal-con-fronteras-dirichlet-a-30-c","title":"Ejemplo 1 (python)  \u2013 Condici\u00f3n inicial diagonal con fronteras Dirichlet a 30 \u00b0C","text":"<p>En este ejemplo se resuelve la ecuaci\u00f3n de calor en 2D con:</p> <ul> <li>Condici\u00f3n inicial: Diagonal (gradiente fuerte de temperatura en la diagonal).</li> <li>Condiciones de frontera: Dirichlet en los cuatro bordes, todas fijadas a 30 \u00b0C.</li> <li>Par\u00e1metros num\u00e9ricos:</li> <li>\\(N = 250\\) puntos interiores por dimensi\u00f3n.</li> <li>\\(M = 500\\) pasos de tiempo.</li> <li>\\(h_x = h_y \\approx 0.003984\\).</li> <li>\\(k = 0.001300\\).</li> <li>\\(\\mu_x = \\mu_y \\approx 81.90\\).</li> <li>Tama\u00f1o del sistema lineal: \\(62500 \\times 62500\\).</li> </ul>"},{"location":"ejemplos/ejemplos-ejecucion/#entradas-y-configuracion-en-la-terminal","title":"Entradas y configuraci\u00f3n en la terminal","text":"<p>====================================================================== ECUACI\u00d3N DE CALOR EN 2D ====================================================================== Selecci\u00f3n de condici\u00f3n inicial   1. Distribuci\u00f3n Gaussiana   2. Anillo   3. Diagonal   4. Forma de U   5. Cuatro esquinas</p> <p>Seleccione una opci\u00f3n (1-5): 3</p> <p>Seleccionado: Diagonal Configuraci\u00f3n de condiciones de frontera</p> <p>Tipos de condici\u00f3n:   Dirichlet: temperatura fija en la frontera   Neumann: flujo de calor en la frontera (0 = aislado)</p> <p>--- Borde Izquierdo --- Tipo de condici\u00f3n (dirichlet/neumann): dirichlet Valor: 30</p> <p>--- Borde Derecho --- Tipo de condici\u00f3n (dirichlet/neumann): dirichlet Valor: 30</p> <p>--- Borde Inferior --- Tipo de condici\u00f3n (dirichlet/neumann): dirichlet Valor: 30</p> <p>--- Borde Superior --- Tipo de condici\u00f3n (dirichlet/neumann): dirichlet Valor: 30 Iniciando simulaci\u00f3n... Configuraci\u00f3n del solver:   N = 250 (puntos interiores por dimensi\u00f3n)   M = 500 (pasos de tiempo)   hx = 0.003984 (paso espacial en x)   hy = 0.003984 (paso espacial en y)   k = 0.001300 (paso temporal)   \u03bcx = 81.901300   \u03bcy = 81.901300   Tama\u00f1o del sistema: 62500 \u00d7 62500</p> <p>Condiciones de frontera:   left: dirichlet = 30.0   right: dirichlet = 30.0   bottom: dirichlet = 30.0   top: dirichlet = 30.0 Resolviendo...</p> <p>An\u00e1lisis de temperatura:   t=0.0000 | Temp. m\u00e1x: 100.0000 | Temp. m\u00edn: 0.0000   t=0.0065 | Temp. m\u00e1x: 44.3588 | Temp. m\u00edn: 2.8183   t=0.0130 | Temp. m\u00e1x: 35.0247 | Temp. m\u00edn: 9.6362   t=0.0195 | Temp. m\u00e1x: 31.6915 | Temp. m\u00edn: 15.5702   t=0.0260 | Temp. m\u00e1x: 30.3708 | Temp. m\u00edn: 19.6366   t=0.0325 | Temp. m\u00e1x: 30.0030 | Temp. m\u00edn: 22.2236   ...   t=0.6435 | Temp. m\u00e1x: 30.0000 | Temp. m\u00edn: 30.0000   t=0.6500 | Temp. m\u00e1x: 30.0000 | Temp. m\u00edn: 30.0000</p>"},{"location":"ejemplos/ejemplos-ejecucion/#interpretacion","title":"Interpretaci\u00f3n","text":"<p>Al inicio, la temperatura presenta un fuerte gradiente diagonal con un m\u00e1ximo de 100 \u00b0C y un m\u00ednimo de 0 \u00b0C.</p> <p>Conforme avanza el tiempo, la temperatura m\u00e1xima desciende y la m\u00ednima aumenta, acerc\u00e1ndose ambas al valor impuesto en las fronteras (30 \u00b0C).</p> <p>Hacia  t\u22480.65 t\u22480.65, el dominio pr\u00e1cticamente alcanza el estado estacionario, con temperaturas muy cercanas a 30 \u00b0C en todo el interior:</p> <p>Temp. m\u00e1x \u2248 30.0000 \u00b0C</p> <p>Temp. m\u00edn \u2248 30.0000 \u00b0C</p> <p>Esto es consistente con la soluci\u00f3n f\u00edsica esperada: con fronteras fijas a 30 \u00b0C y sin fuentes internas, la ecuaci\u00f3n de calor conduce a un estado de equilibrio t\u00e9rmico uniforme.</p>"},{"location":"ejemplos/ejemplos-ejecucion/#figura-1-distribucion-inicial-condicion-diagonal","title":"Figura 1 \u2014 Distribuci\u00f3n inicial (condici\u00f3n diagonal)","text":""},{"location":"ejemplos/ejemplos-ejecucion/#figura-2-distribucion-final-despues-de-la-simulacion","title":"Figura 2 \u2014 Distribuci\u00f3n final despu\u00e9s de la simulaci\u00f3n","text":""},{"location":"ejemplos/ejemplos-ejecucion/#ejemplo-2-c-resultados-de-la-paralelizacion-en-c","title":"Ejemplo 2 (C++) - Resultados de la paralelizaci\u00f3n en C++","text":"<p>Hilos   Tiempo del test 1       820.46 2       460.65 3       371.43 4       328.14 5       309.12 6       294.48 7       271.75 8       235.58 9       227.19 10      219.96 11      207.27 12      202.15 13      239.96</p>"},{"location":"ejemplos/ejemplos-ejecucion/#figura-3-grafico-de-speed-up-en-funcion-del-numero-de-hilos","title":"Figura 3 \u2014 Gr\u00e1fico de Speed up en funci\u00f3n del n\u00famero de hilos","text":""},{"location":"implementacion/cpp/","title":"C++","text":""},{"location":"implementacion/cpp/#metodo-iterativo-gauss-seidel","title":"M\u00e9todo Iterativo Gauss-Seidel","text":"<p>Para resolver Ax = b, Gauss-Seidel actualiza cada componente secuencialmente:</p> \\[x_i^{\\text{new}} = \\frac{1}{a_{ii}} \\left( b_i - \\sum_{j&lt;i} a_{ij} x_j^{\\text{new}} - \\sum_{j&gt;i} a_{ij} x_j^{\\text{old}} \\right)\\]"},{"location":"implementacion/cpp/#pseudocodigo","title":"Pseudoc\u00f3digo","text":"<pre><code>x = 0\nrepeat\n    max_diff = 0\n    for i = 1..N:\n        sigma = sum_{j != i} a[i,j] * x[j]\n        x_new = (b[i] - sigma)/a[i,i]\n        max_diff = max(max_diff, |x_new - x[i]|)\n        x[i] = x_new\nuntil max_diff &lt; tol\n</code></pre>"},{"location":"implementacion/cpp/#convergencia","title":"Convergencia","text":"<p>La principal diferencia con el m\u00e9todo de Jacobi es que Gauss-Seidel utiliza valores reci\u00e9n calculados tan pronto como est\u00e1n disponibles; esta diferencia hace que Gauss-Seidel converja m\u00e1s r\u00e1pido que Jacobi en la mayor\u00eda de los casos.</p>"},{"location":"implementacion/cpp/#condiciones-de-convergencia","title":"Condiciones de convergencia","text":"<ol> <li>Matriz Diagonalmente Dominante:</li> </ol> \\[|a_{ii}| &gt; \\sum_{j \\neq i} |a_{ij}| \\quad \\text{para todo } i\\] <ol> <li> <p>Matriz Sim\u00e9trica Definida Positiva (SPD):</p> <ul> <li>\\(A = A^T\\) (sim\u00e9trica)</li> <li>Todos los valores propios &gt; 0</li> </ul> </li> <li> <p>Matriz con Elementos Positivos en la Diagonal: Si \\(a_{ii} &gt; 0\\) y la matriz es irreducible, converge.</p> </li> </ol> <p>Propiamente, para el sistema \\((I - kA)u^{n+1} = u^n\\):</p> <ul> <li>La matriz \\(I - kA\\) es diagonalmente dominante cuando \\(k\\) es peque\u00f1o</li> <li>Es sim\u00e9trica definida positiva porque \\(A\\) (Laplaciano discreto) es SPD</li> <li>Esto garantiza la convergencia de Gauss-Seidel</li> </ul>"},{"location":"implementacion/cpp/#ejemplo","title":"Ejemplo","text":"<p>Supongamos el sistema:</p> \\[\\begin{bmatrix} 4 &amp; 1 \\\\ 1 &amp; 3 \\end{bmatrix} \\begin{bmatrix} x_1 \\\\ x_2 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}\\] <p>Gauss-Seidel actualiza primero \\(x_1\\) usando \\(x_2\\) antiguo, luego \\(x_2\\) usando el nuevo \\(x_1\\). Tras varias iteraciones, converge a la soluci\u00f3n exacta.</p>"},{"location":"implementacion/cpp/#esquema-red-black","title":"Esquema Red-Black","text":"<p>Para mejorar la paralelizaci\u00f3n y la convergencia, se colorea la malla como un tablero de ajedrez:</p> <ul> <li>Nodos rojos: \\((i + j) \\mod 2 = 0\\)</li> <li>Nodos negros: \\((i + j) \\mod 2 = 1\\)</li> </ul> <p>Primero se actualizan los nodos rojos usando valores negros antiguos, luego los negros usando valores rojos nuevos. Esto acelera la convergencia respecto al Gauss-Seidel est\u00e1ndar.</p>"},{"location":"implementacion/cpp/#condiciones-de-frontera","title":"Condiciones de frontera","text":"<p>El c\u00f3digo permite elegir condiciones de frontera:</p> <ul> <li>Dirichlet homog\u00e9nea (\\(u = 0\\)): paredes fr\u00edas, el calor se fuga y la soluci\u00f3n tiende a cero.</li> <li>Dirichlet fija (\\(u = T_{\\text{borde}}\\)): se fuerzan temperaturas de borde, la soluci\u00f3n alcanza equilibrio estacionario.</li> <li>Neumann (\\(\\frac{\\partial u}{\\partial n} = 0\\)): frontera aislada, no hay transferencia de calor hacia afuera, la energ\u00eda total se conserva.</li> </ul>"},{"location":"implementacion/cpp/#ejemplo-fisico","title":"Ejemplo f\u00edsico","text":"<p>Si se coloca un pulso de calor inicial en el centro:</p> <ul> <li>Con Dirichlet \\(u = 0\\), el pulso se disipa r\u00e1pidamente.</li> <li>Con Dirichlet fija, el sistema alcanza un estado estacionario con temperaturas de borde constantes.</li> <li>Con Neumann, el calor permanece dentro del dominio y se redistribuye hasta homogenizarse.</li> </ul>"},{"location":"implementacion/cpp/#flujo-completo-del-programa","title":"Flujo completo del programa","text":"<ol> <li>Se imprimen opciones de frontera y el usuario elige una.</li> <li>Se construye el objeto solver correspondiente.</li> <li>Se genera la condici\u00f3n inicial (ejemplo: distribuci\u00f3n gaussiana).</li> <li>Para cada paso de tiempo:     (a) Se ejecuta el solver iterativo.     (b) Se guarda un snapshot si corresponde.     (c) Se analiza m\u00e1ximo y m\u00ednimo de la temperatura.</li> </ol>"},{"location":"implementacion/cpp/#relacion-entre-euler-implicito-y-gauss-seidel","title":"Relaci\u00f3n entre Euler Impl\u00edcito y Gauss-Seidel","text":"<ul> <li>Euler impl\u00edcito convierte la PDE en un sistema lineal.</li> <li>Gauss-Seidel (o Red-Black) es el m\u00e9todo usado para resolver ese sistema.</li> <li> <p>En cada paso temporal se ejecutan m\u00faltiples iteraciones de Gauss-Seidel hasta convergencia.</p> </li> <li> </li> </ul> <p>En la resoluci\u00f3n num\u00e9rica de la ecuaci\u00f3n de calor en dos dimensiones mediante el m\u00e9todo de Euler impl\u00edcito, cada paso de tiempo requiere resolver un sistema lineal grande. Este sistema se resuelve con Gauss\u2013Seidel, pero su versi\u00f3n cl\u00e1sica es totalmente secuencial, ya que cada punto depende de las actualizaciones recientes de sus vecinos. Esto hace que el m\u00e9todo sea lento cuando la malla es grande. Para aprovechar los procesadores multin\u00facleo y reducir los tiempos de c\u00f3mputo, se combinan dos t\u00e9cnicas muy utilizadas en paralelizaci\u00f3n: el esquema Red\u2013Black Gauss\u2013Seidel y la divisi\u00f3n de la malla en bloques o tiles.</p>"},{"location":"implementacion/cpp/#paralelizacion-redblack-con-bloques-tiling","title":"Paralelizaci\u00f3n Red\u2013Black con Bloques (Tiling)","text":""},{"location":"implementacion/cpp/#metodo-redblack","title":"M\u00e9todo Red\u2013Black","text":"<p>La idea del m\u00e9todo Red\u2013Black es dividir la malla como si fuera un tablero de ajedrez: los nodos donde (i + j) es par se marcan como rojos, y los nodos donde (i + j) es impar como negros. Esta separaci\u00f3n no es arbitraria; garantiza que cada nodo rojo tenga \u00fanicamente vecinos negros, y que cada nodo negro tenga solo vecinos rojos. Esto permite eliminar dependencias y volver paralelizable un m\u00e9todo que originalmente era secuencial.</p> <p>De esta forma, primero se pueden actualizar todos los nodos rojos en paralelo, y luego todos los nodos negros (o al rev\u00e9s). Gracias a esto, cada conjunto de nodos puede procesarse sin esperar al otro, permitiendo paralelizar Gauss\u2013Seidel de manera efectiva. <pre><code>for (int fase = 0; fase &lt; 2; fase++) {   // 0 = rojos, 1 = negros\n    #pragma omp parallel for collapse(2) reduction(max:maxDiff) schedule(static)\n    for (int bijy = 0; bijy &lt; nBlocksY; bijy++) {\n        for (int bxi = 0; bxi &lt; nBlocksX; bxi++) {\n            ...\n            for (int j = jStart; j &lt; jEnd; j++) {\n                for (int i = iStart; i &lt; iEnd; i++) {\n                    if ((i + j) % 2 != fase) continue; // Red-Black\n\n                    double newValue = ...\n                    maxDiff = max(maxDiff, fabs(newValue - current[idx]));\n                    current[idx] = newValue;\n                }\n            }\n        }\n    }\n}\n</code></pre></p>"},{"location":"implementacion/cpp/#directivas-openmp","title":"Directivas OpenMP","text":""},{"location":"implementacion/cpp/#pragma-omp-parallel-for-collapse2","title":"<code>#pragma omp parallel for collapse(2)</code>","text":"<p>Este pragma indica que los bucles externos (los que recorren los bloques en las direcciones X e Y) se deben paralelizar. El uso de <code>collapse(2)</code> le dice a OpenMP que combine ambos bucles en uno solo, creando un conjunto de iteraciones m\u00e1s grande y uniforme. Esto ayuda a repartir mejor los bloques entre los hilos y evita que algunos queden sin trabajo cuando una dimensi\u00f3n tiene pocos bloques.</p> <ul> <li>Sin collapse: solo se paraleliza por filas de bloques.</li> <li>Con collapse: todos los bloques se reparten equitativamente.</li> </ul> <p>Sin collapse, es com\u00fan que algunos hilos se queden esperando mientras otros a\u00fan siguen trabajando.</p>"},{"location":"implementacion/cpp/#schedulestatic","title":"<code>schedule(static)</code>","text":"<p>El modo <code>static</code> se usa porque:</p> <ul> <li>Todos los bloques requieren pr\u00e1cticamente el mismo esfuerzo computacional.</li> <li>El tama\u00f1o del trabajo por bloque es muy similar.</li> <li>Se evita el costo adicional del planificador <code>dynamic</code>, que introduce m\u00e1s sincronizaciones.</li> </ul> <p>Con esto se logra una distribuci\u00f3n r\u00e1pida, simple y eficiente del c\u00e1lculo entre hilos.</p>"},{"location":"implementacion/cpp/#reductionmaxmaxdiff","title":"<code>reduction(max:maxDiff)</code>","text":"<p>En cada iteraci\u00f3n se debe calcular la norma infinita del error:</p> \\[ \\max|u^{(k+1)} - u^{(k)}| \\] <p>Como varios hilos contribuyen a este c\u00e1lculo al mismo tiempo, se utiliza una reducci\u00f3n de tipo <code>max</code>. Esto permite que cada hilo compute su propio valor local sin interferir con los dem\u00e1s y que al final todos se combinen de forma segura para obtener el m\u00e1ximo global, evitando condiciones de carrera.</p>"},{"location":"implementacion/cpp/#division-en-bloques-tiling","title":"Divisi\u00f3n en Bloques (Tiling)","text":"<p>Adem\u00e1s del coloreo Red-Black, la malla tambi\u00e9n se divide en bloques rectangulares (por ejemplo, de 32 x 32 celdas). Cada bloque se asigna a un hilo mediante OpenMP. Esto aporta varios beneficios importantes:</p> <ul> <li>Se reducen los accesos a memoria RAM</li> <li>Los datos cercanos se reutilizan dentro del bloque</li> <li>Los bloques se distribuyen de forma balanceada entre los hilos</li> <li>Se evita que varios hilos trabajen sobre datos demasiado pr\u00f3ximos, reduciendo el riesgo de false sharing</li> </ul> <p>La combinaci\u00f3n del tiling con el esquema Red\u2013Black genera un paralelismo muy eficiente que escala bien con el n\u00famero de n\u00facleos del procesador. <pre><code>const int BX = 32, BY = 32;\nconst int nBlocksX = (N + BX - 1) / BX;\nconst int nBlocksY = (N + BY - 1) / BY;\n\nint jStart = bjy * BY, jEnd = min(N, jStart + BY);\nint iStart = bxi * BX, iEnd = min(N, iStart + BX);\n</code></pre></p> <p>As\u00ed, cada hilo trabaja sobre un bloque bien delimitado, cuyos datos permanecen dentro de las caches del procesador durante casi toda la operaci\u00f3n, lo que incrementa significativamente el rendimiento general.</p>"},{"location":"implementacion/python/","title":"Implementaci\u00f3n en Python","text":"<p>La implementaci\u00f3n en Python utiliza NumPy para operaciones matriciales y SciPy para resolver el sistema lineal disperso de manera eficiente.</p>"},{"location":"implementacion/python/#arquitectura-del-codigo","title":"Arquitectura del C\u00f3digo","text":""},{"location":"implementacion/python/#clase-principal-heatequation2d","title":"Clase Principal: <code>HeatEquation2D</code>","text":"<pre><code>class HeatEquation2D:\n    def __init__(self, N=150, M=200, T=0.5, a=1.0, b=1.0, c=1.0,\n                 condiciones_frontera=None)\n    def MatrizLaplaciano(self)\n    def VectorRHS(self, tn, u_prev)\n    def obtener_valor_frontera(self, lado, t, pos)\n    def solve(self, u0_func, save_every=1)\n</code></pre>"},{"location":"implementacion/python/#componentes-principales","title":"Componentes Principales","text":""},{"location":"implementacion/python/#1-inicializacion","title":"1. Inicializaci\u00f3n","text":"<p>Aqui simplemente se definen los parametros con los que se van a trabajar y se definen como atributos de la clase:</p> <pre><code>def __init__(self, N=150, M=200, T=0.5, a=1.0, b=1.0, c=1.0,\n             condiciones_frontera=None):\n    self.N = N\n    self.M = M\n    self.T = T\n    self.a = a\n    self.b = b\n    self.c = c\n\n    # Pasos espaciales y temporales\n    self.hx = a / (N + 1)\n    self.hy = b / (N + 1)\n    self.k = T / M\n\n    # Par\u00e1metros de discretizaci\u00f3n\n    self.mux = (c**2 * self.k) / self.hx**2\n    self.muy = (c**2 * self.k) / self.hy**2\n\n    # Malla espacial (solo puntos interiores)\n    self.x = np.linspace(self.hx, a - self.hx, N)\n    self.y = np.linspace(self.hy, b - self.hy, N)\n    self.X, self.Y = np.meshgrid(self.x, self.y)\n\n    # Construir matriz del sistema\n    self.A = self.MatrizLaplaciano()\n</code></pre>"},{"location":"implementacion/python/#2-construccion-de-la-matriz-del-sistema","title":"2. Construcci\u00f3n de la Matriz del Sistema","text":"<p>Se elige construir la matriz A en formato LIL ya que es un formato eficiente para construir matrices dispersas elemento por elemento. El elemento idx proyecta los elementos \\((i,j)\\) en una dimension ordenandolos por fila. Ademas, se guarda como csr para optimizar las operaciones algebraicas.</p> <pre><code>def MatrizLaplaciano(self):\n        N = self.N\n        A = lil_matrix((N * N, N * N))\n\n        # Pre-calcular tipos de condiciones para cada borde\n        left_type = self.condiciones_frontera['left']['type']\n        right_type = self.condiciones_frontera['right']['type']\n        bottom_type = self.condiciones_frontera['bottom']['type']\n        top_type = self.condiciones_frontera['top']['type']\n\n        for j in range(N):\n            for i in range(N):\n                idx = j * N + i\n\n                # Diagonal: siempre 1 + 2\u03bcx + 2\u03bcy\n                A[idx, idx] = 1.0 + 2.0 * self.mux + 2.0 * self.muy\n\n                # Vecinos en x\n                # Est\u00e1 en borde izquierdo\n                if i == 0:\n                    if left_type == 'neumann':\n                        # En borde izquierdo con Neumann\n                        # No hay coeficiente para vecino izquierdo (fantasma)\n                        # Pero el vecino derecho (si existe) tiene -2\u03bcx\n                        if i &lt; N - 1:  # Existe vecino derecho\n                            A[idx, idx + 1] = -2.0 * self.mux\n                    else:\n                        # Dirichlet en borde izquierdo\n                        # Coeficiente normal para vecino derecho\n                        if i &lt; N - 1:\n                            A[idx, idx + 1] = -self.mux\n                # Est\u00e1 en borde derecho\n                elif i == N - 1:\n                    if right_type == 'neumann':\n                        # En borde derecho con Neumann\n                        # Vecino izquierdo tiene -2\u03bcx\n                        A[idx, idx - 1] = -2.0 * self.mux\n                    else:\n                        # Dirichlet en borde derecho\n                        # Coeficiente normal para vecino izquierdo\n                        A[idx, idx - 1] = -self.mux\n                else:\n                    # Punto interior en x\n                    A[idx, idx - 1] = -self.mux  # Vecino izquierdo\n                    A[idx, idx + 1] = -self.mux  # Vecino derecho\n\n                # Vecinos en Y\n\n                # Est\u00e1 en borde inferior\n                if j == 0:\n                    if bottom_type == 'neumann':\n                        # En borde inferior con Neumann\n                        # Vecino superior (si existe) tiene -2\u03bcy\n                        if j &lt; N - 1:\n                            A[idx, idx + N] = -2.0 * self.muy\n                    else:\n                        # Dirichlet en borde inferior\n                        if j &lt; N - 1:\n                            A[idx, idx + N] = -self.muy\n                # Est\u00e1 en borde superior\n                elif j == N - 1:\n                    if top_type == 'neumann':\n                        # En borde superior con Neumann\n                        # Vecino inferior tiene -2\u03bcy\n                        A[idx, idx - N] = -2.0 * self.muy\n                    else:\n                        # Dirichlet en borde superior\n                        A[idx, idx - N] = -self.muy\n                else:\n                    # Punto interior en y\n                    A[idx, idx - N] = -self.muy  # Vecino inferior\n                    A[idx, idx + N] = -self.muy  # Vecino superior\n\n        return A.tocsr()\n</code></pre>"},{"location":"implementacion/python/#3-construccion-del-vector-rhs","title":"3. Construcci\u00f3n del Vector RHS","text":"<p>Aqui simplemente se construye el vector segun el tipo de condicion y el borde que se tenga.</p> <pre><code>def VectorRHS(self, tn, u_prev):\n        \"\"\"\n        aqui se construye el vector del lado derecho\n\n        se dedujo que:\n        - borde izquierdo Neumann:  b = u\u207f - 2\u03bcx\u00b7hx\u00b7g\n        - borde derecho Neumann:    b = u\u207f + 2\u03bcx\u00b7hx\u00b7g\n        - borde inferior Neumann:   b = u\u207f - 2\u03bcy\u00b7hy\u00b7g\n        - borde superior Neumann:   b = u\u207f + 2\u03bcy\u00b7hy\u00b7g\n        - Dirichlet:                b = u\u207f + \u03bc\u00b7g\n\n        esto es lo que se desarrolla aca\n        \"\"\"\n        N = self.N\n        b = u_prev.copy()  # empezamos con las temperaturas anteriores (o sea, u\u207f)\n\n        # bordes izquierdo y derecho (i fijo)\n        for j in range(N):\n            y_pos = self.y[j]  # posicion en y\n\n            # borde izquierdo (i=0)\n            idx_left = j * N  # j*N + 0\n            if self.condiciones_frontera['left']['type'] == 'dirichlet':\n                # Dirichlet: u = g en el borde\n                g_left = self.condiciones_frontera['left']['valor']\n                # se a\u00f1ade el t\u00e9rmino necesario\n                b[idx_left] += self.mux * g_left\n\n            elif self.condiciones_frontera['left']['type'] == 'neumann':\n                # Neumann: \u2202u/\u2202x = g en el borde\n                g_left = self.condiciones_frontera['left']['valor']\n                # se a\u00f1ade el t\u00e9rmino necesario\n                b[idx_left] -= 2.0 * self.mux * self.hx * g_left\n\n            # borde derecho (i=N-1), todo es la misma l\u00f3gica que para el borde\n            # izq\n            idx_right = j * N + (N - 1)\n            if self.condiciones_frontera['right']['type'] == 'dirichlet':\n                g_right = self.condiciones_frontera['right']['valor']\n                b[idx_right] += self.mux * g_right\n\n            elif self.condiciones_frontera['right']['type'] == 'neumann':\n                g_right = self.condiciones_frontera['right']['valor']\n                b[idx_right] += 2.0 * self.mux * self.hx * g_right\n\n        # bordes inferior y superior (j fijo), igual todo es con la misma\n        # l\u00f3gica y se usan las mismas f\u00f3rmulas\n        for i in range(N):\n            x_pos = self.x[i]  # posici\u00f3n en x\n\n            # borde inferior (j=0)\n            idx_bottom = i  # 0*N + i = i\n            if self.condiciones_frontera['bottom']['type'] == 'dirichlet':\n                g_bottom = self.condiciones_frontera['bottom']['valor']\n                b[idx_bottom] += self.muy * g_bottom\n\n            elif self.condiciones_frontera['bottom']['type'] == 'neumann':\n                g_bottom = self.condiciones_frontera['bottom']['valor']\n                b[idx_bottom] -= 2.0 * self.muy * self.hy * g_bottom\n\n            # borde superior (j=N-1)\n            idx_top = (N - 1) * N + i\n            if self.condiciones_frontera['top']['type'] == 'dirichlet':\n                g_top = self.obtener_valor_frontera['top']['valor']\n                b[idx_top] += self.muy * g_top\n\n            elif self.condiciones_frontera['top']['type'] == 'neumann':\n                g_top = self.condiciones_frontera['top']['valor']\n                b[idx_top] += 2.0 * self.muy * self.hy * g_top\n\n        return b\n</code></pre>"},{"location":"implementacion/python/#4-solver-principal","title":"4. Solver Principal","text":"<p>Se inicializa el vector \\(u0\\) con la condicion inicial evaluada en cada puntos y se almacena en la lista de soluciones.</p> <p>Despues hay un bucle temporal en el que para cado paso n se calcula el tiempo actual, ademas construye el vector b basandose en \\(u_prev\\) y en las condiciones de frontera en el tiempo actual.</p> <p>Con esto ya armado, se resuelve para u_actual con la funcion spsolve, que es una funcion de SciPy para resolver sistemas lineales dispersos.</p> <pre><code>def solve(self, u0_func, save_every=1):\n        # resuelve la ecuaci\u00f3n de calor\n        N = self.N\n\n       # condicion inicial\n        u0 = np.zeros(N * N)\n        for j in range(N):\n            for i in range(N):\n                idx = j * N + i\n                u0[idx] = u0_func(self.x[i], self.y[j])\n\n        soluciones = [u0.reshape(N, N).copy()]\n        tiempos = [0.0]\n        u_prev = u0\n\n        print(f\"Resolviendo...\")\n\n        # evoluci\u00f3n temporal\n        for n in range(1, self.M + 1):\n            tn = n * self.k  # tiempo actual\n\n            # se construye el vector del lado derecho\n            b = self.VectorRHS(tn, u_prev)\n\n            # se resuelve sistema lineal A\u00b7u^{n+1} = b\n            u_actual = spsolve(self.A, b)\n\n            if n % save_every == 0 or n == self.M:\n                soluciones.append(u_actual.reshape(N, N).copy())\n                tiempos.append(tn)\n\n            u_prev = u_actual\n\n        return soluciones, tiempos\n</code></pre>"},{"location":"implementacion/python/#condiciones","title":"Condiciones","text":"<p>Se ponen cinco condiciones iniciales con una temperatura inicial de 100 grados celsius:</p>"},{"location":"implementacion/python/#1-distribucion-gaussiana","title":"1. Distribuci\u00f3n Gaussiana","text":"<pre><code>def DistribucionGaussiana(x, y):\n    \"\"\"Pico gaussiano centrado en (0.5, 0.5)\"\"\"\n    return 100 * np.exp(-50 * ((x - 0.5)**2 + (y - 0.5)**2))\n</code></pre>"},{"location":"implementacion/python/#2-anillo","title":"2. Anillo","text":"<pre><code>def Anillo(x, y):\n    \"\"\"Distribuci\u00f3n en forma de anillo\"\"\"\n    r = np.sqrt((x - 0.5)**2 + (y - 0.5)**2)\n    return 100 * np.exp(-200 * (r - 0.3)**2)\n</code></pre>"},{"location":"implementacion/python/#3-diagonal","title":"3. Diagonal","text":"<pre><code>def Diagonal(x, y):\n    \"\"\"Franja diagonal caliente\"\"\"\n    return 100 * np.exp(-100 * (x - y)**2)\n</code></pre>"},{"location":"implementacion/python/#4-forma-de-u","title":"4. Forma de U","text":"<pre><code>def FormaU(x, y):\n    \"\"\"Tres puntos calientes formando U\"\"\"\n    left = np.exp(-200 * ((x - 0.25)**2 + (y - 0.5)**2))\n    right = np.exp(-200 * ((x - 0.75)**2 + (y - 0.5)**2))\n    bottom = np.exp(-200 * ((x - 0.5)**2 + (y - 0.25)**2))\n    return 100 * (left + right + bottom)\n</code></pre>"},{"location":"implementacion/python/#5-cuatro-esquinas","title":"5. Cuatro Esquinas","text":"<pre><code>def CuatroEsquinas(x, y):\n    \"\"\"Cuatro puntos calientes en las esquinas\"\"\"\n    sigma = 0.08\n    return 100 * (\n        np.exp(-((x - 0.1)**2 + (y - 0.1)**2) / (2 * sigma**2)) +\n        np.exp(-((x - 0.9)**2 + (y - 0.1)**2) / (2 * sigma**2)) +\n        np.exp(-((x - 0.1)**2 + (y - 0.9)**2) / (2 * sigma**2)) +\n        np.exp(-((x - 0.9)**2 + (y - 0.9)**2) / (2 * sigma**2))\n    )\n</code></pre> <p>Ademas de esto, se implementa una funcion que imprime las temperaturas maximas y minimas en el sistema en un determinado tiempo.</p> <pre><code>def analyze_min_max(soluciones, tiempos):\n    print(\"\\nAn\u00e1lisis de temperatura:\")\n    for i, (sol, t) in enumerate(zip(soluciones, tiempos)):\n        u_max = sol.max()\n        u_min = sol.min()\n        print(f\"  t={t:.4f} | Temp. m\u00e1x: {u_max:.4f} | Temp. m\u00edn: {u_min:.4f}\")\n</code></pre>"},{"location":"implementacion/python/#menu-interactivo","title":"Menu interactivo","text":"<p>Se implementaron funciones que permiten al usuario elegir las condiciones iniciales y las condiciones de frontera para cada uno de los bordes de la malla.</p> <pre><code>def seleccionar_condicion_inicial():\n    \"\"\"\n    Permite al usuario seleccionar una condici\u00f3n inicial.\n    \"\"\"\n    print(\"Selecci\u00f3n de condici\u00f3n inicial\")\n    print(\"  1. Distribuci\u00f3n Gaussiana\")\n    print(\"  2. Anillo\")\n    print(\"  3. Diagonal\")\n    print(\"  4. Forma de U\")\n    print(\"  5. Cuatro esquinas\")\n\n    condiciones = {\n        1: (\"Distribuci\u00f3n Gaussiana\", DistribucionGaussiana),\n        2: (\"Anillo\", Anillo),\n        3: (\"Diagonal\", Diagonal),\n        4: (\"Forma de U\", FormaU),\n        5: (\"Cuatro esquinas\", CuatroEsquinas)\n    }\n\n    while True:\n\n\n      while True:\n        try:\n            opcion = int(input(\"\\nSeleccione una opci\u00f3n (1-5): \").strip())\n            if opcion in condiciones:\n                nombre, funcion = condiciones[opcion]\n                print(f\"\\nSeleccionado: {nombre}\")\n                return funcion\n            else:\n                print(\"Error: Ingrese un n\u00famero entre 1 y 4\")\n        except ValueError:\n            print(\"Error: Ingrese un n\u00famero v\u00e1lido\")\n\n\ndef solicitar_condiciones_frontera():\n    \"\"\"\n    Solicita al usuario las condiciones de frontera para cada lado del dominio.\n    \"\"\"\n    print(\"Configuraci\u00f3n de condiciones de frontera\")\n    print(\"\\nTipos de condici\u00f3n:\")\n    print(\"  Dirichlet: temperatura fija en la frontera\")\n    print(\"  Neumann: flujo de calor en la frontera (0 = aislado)\")\n\n    condiciones_frontera = {}\n    lados = ['left', 'right', 'bottom', 'top']\n    lado_nombres = {\n        'left': 'Izquierdo',\n        'right': 'Derecho',\n        'bottom': 'Inferior',\n        'top': 'Superior'\n    }\n\n    for lado in lados:\n        print(f\"\\n--- Borde {lado_nombres[lado]} ---\")\n\n        while True:\n            tipo = input(f\"Tipo de condici\u00f3n (dirichlet/neumann): \").strip().lower()\n            if tipo in ['dirichlet', 'neumann', 'd', 'n']:\n                if tipo == 'd':\n                    tipo = 'dirichlet'\n                elif tipo == 'n':\n                    tipo = 'neumann'\n                break\n            print(\"Error: Ingrese 'dirichlet' (o 'd') o 'neumann' (o 'n')\")\n\n        while True:\n            try:\n                valor_str = input(f\"Valor: \").strip()\n                valor = float(valor_str)\n                break\n            except ValueError:\n                print(\"Error: Ingrese un n\u00famero v\u00e1lido\")\n\n        condiciones_frontera[lado] = {'type': tipo, 'valor': valor}\n\n    return condiciones_frontera\n</code></pre>"},{"location":"implementacion/python/#visualizacion-y-animacion","title":"Visualizaci\u00f3n y Animaci\u00f3n","text":""},{"location":"implementacion/python/#funcion-de-animacion","title":"Funci\u00f3n de Animaci\u00f3n","text":"<pre><code>def crear_animacion(soluciones, tiempos, titulo, condiciones_frontera, \n                   intervalo=500):\n    \"\"\"\n    Crea animaci\u00f3n de la evoluci\u00f3n de temperatura.\n\n    Par\u00e1metros:\n    -----------\n    soluciones : list\n        Lista de arrays 2D con soluciones\n    tiempos : list\n        Tiempos correspondientes\n    titulo : str\n        T\u00edtulo de la animaci\u00f3n\n    condiciones_frontera : dict\n        Condiciones de frontera usadas\n    intervalo : int\n        Milisegundos entre frames\n    \"\"\"\n    fig, ax = plt.subplots(figsize=(10, 8))\n\n    # Rango de colores consistente\n    vmin = min(sol.min() for sol in soluciones)\n    vmax = max(sol.max() for sol in soluciones)\n\n    # Imagen inicial\n    im = ax.imshow(soluciones[0], cmap='hot', interpolation='bilinear',\n                   origin='lower', vmin=vmin, vmax=vmax, \n                   extent=[0, 1, 0, 1])\n\n    # Barra de color\n    cbar = plt.colorbar(im, ax=ax, label='Temperatura')\n\n    # Funci\u00f3n de actualizaci\u00f3n\n    def actualizar(frame):\n        im.set_array(soluciones[frame])\n        # Actualizar informaci\u00f3n de tiempo y temperatura\n        # ...\n        return [im]\n\n    anim = FuncAnimation(fig, actualizar, frames=len(soluciones),\n                        interval=intervalo, blit=True, repeat=True)\n\n    return anim\n</code></pre>"},{"location":"matematica/condiciones/","title":"Condiciones de Frontera","text":""},{"location":"matematica/condiciones/#tipos-de-condiciones","title":"Tipos de Condiciones","text":""},{"location":"matematica/condiciones/#1-condiciones-de-dirichlet","title":"1. Condiciones de Dirichlet","text":""},{"location":"matematica/condiciones/#implementacion-numerica","title":"Implementaci\u00f3n Num\u00e9rica","text":"<p>Para una frontera izquierda con temperatura \\(g\\):</p> \\[ u_{0,j}^{n+1} = g(y_j, t_{n+1}) \\] <p>Este es un valor conocido, por lo que se mueve al lado derecho del sistema:</p> <pre><code># Punto interior m\u00e1s cercano a la frontera izquierda\nidx = j * N + 0  # i = 0\n\n# T\u00e9rmino que se a\u00f1ade al RHS\nb[idx] += mu_x * g_left(y_j, t_n)\n</code></pre> <p>La logica es la misma los otros bordes.</p>"},{"location":"matematica/condiciones/#2-condiciones-de-neumann","title":"2. Condiciones de Neumann","text":""},{"location":"matematica/condiciones/#implementacion-numerica-con-puntos-fantasma","title":"Implementaci\u00f3n num\u00e9rica con Puntos Fantasma","text":"<p>Para implementar condiciones de Neumann, introducimos puntos fantasma fuera del dominio.</p>"},{"location":"matematica/condiciones/#frontera-izquierda-x-0","title":"Frontera Izquierda (\\(x = 0\\))","text":"<p>La condici\u00f3n de Neumann es:</p> \\[ \\frac{\\partial u}{\\partial x}\\bigg|_{x=0} = g(y, t) \\] <p>Se aproxima esta derivada por diferencias centrales:</p> \\[ \\frac{u_{1,j} - u_{-1,j}}{2h_x} = g(y_j, t) \\] <p>donde \\(u_{-1,j}\\) es el punto fantasma.</p> <p>Se despeja este punto fantasma::</p> \\[ u_{-1,j} = u_{1,j} - 2h_x \\cdot g(y_j, t) \\] <p>Se sustituye en la ecuacion de calor discretizada:</p> \\[ \\begin{align} (1 + 2\\mu_x + 2\\mu_y)u_{0,j}^{n+1} - \\mu_x(2u_{1,j}^{n+1} - 2h_x g) - \\mu_y(u_{0,j-1}^{n+1} + u_{0,j+1}^{n+1}) = u_{0,j}^n \\end{align} \\] \\[ (1 + 2\\mu_x + 2\\mu_y)u_{0,j}^{n+1} - 2\\mu_xu_{1,j}^{n+1}  - \\mu_y(u_{0,j-1}^{n+1} + u_{0,j+1}^{n+1}) = u_{0,j}^n - 2h_x g \\mu_x \\]"},{"location":"matematica/condiciones/#modificaciones-al-sistema-lineal","title":"Modificaciones al Sistema Lineal","text":"<p>Como se puede ver, los resultados anteriores modifican el planteamiento del sistema lineal que obtuvimos en la derivacion anterior:</p>"},{"location":"matematica/condiciones/#en-la-matriz-a","title":"En la Matriz \\(A\\)","text":"<p>El coeficiente del vecino en la direcci\u00f3n de la frontera se duplica:</p> <p>Antes (Dirichlet o punto interior): <pre><code>A[idx, idx]     =  1 + 2\u03bc\u2093 + 2\u03bc\u1d67\nA[idx, idx+1]   = -\u03bc\u2093           (vecino derecho)\n</code></pre></p> <p>Ahora (Neumann izquierda): <pre><code>A[idx, idx]     =  1 + 2\u03bc\u2093 + 2\u03bc\u1d67\nA[idx, idx+1]   = -2\u03bc\u2093          (coeficiente duplicado)\n</code></pre></p>"},{"location":"matematica/condiciones/#en-el-vector-b-rhs","title":"En el Vector \\(b\\) (RHS)","text":"<p>Se a\u00f1ade el t\u00e9rmino del flujo:</p> <pre><code>b[idx] -= 2 * mu_x * h_x * g(y_j, t_n)\n</code></pre> <p>Signo: Depende de la orientaci\u00f3n de la normal exterior: - Frontera izquierda: \\(-2\\mu_x h_x g\\) - Frontera derecha: \\(+2\\mu_x h_x g\\) - Frontera inferior: \\(-2\\mu_y h_y g\\) - Frontera superior: \\(+2\\mu_y h_y g\\)</p>"},{"location":"matematica/condiciones/#tabla-de-modificaciones","title":"Tabla de Modificaciones","text":"<p>Se presenta la siguiente tabla a modo de resumen:</p> Frontera Normal Coeficiente duplicado T\u00e9rmino RHS Izquierda (\\(x=0\\)) \\(-\\hat{x}\\) \\(A[idx, idx+1] = -2\\mu_x\\) \\(-2\\mu_x h_x g\\) Derecha (\\(x=a\\)) \\(+\\hat{x}\\) \\(A[idx, idx-1] = -2\\mu_x\\) \\(+2\\mu_x h_x g\\) Inferior (\\(y=0\\)) \\(-\\hat{y}\\) \\(A[idx, idx+N] = -2\\mu_y\\) \\(-2\\mu_y h_y g\\) Superior (\\(y=b\\)) \\(+\\hat{y}\\) \\(A[idx, idx-N] = -2\\mu_y\\) \\(+2\\mu_y h_y g\\)"},{"location":"matematica/formulacion/","title":"Formulaci\u00f3n Matem\u00e1tica","text":""},{"location":"matematica/formulacion/#la-ecuacion-de-calor","title":"La Ecuaci\u00f3n de Calor","text":"<p>La ecuaci\u00f3n de calor en dos dimensiones es una ecuaci\u00f3n diferencial parcial parab\u00f3lica que describe la distribuci\u00f3n de temperatura en una regi\u00f3n espacial a lo largo del tiempo.</p>"},{"location":"matematica/formulacion/#ecuacion-diferencial","title":"Ecuaci\u00f3n Diferencial","text":"<p>La forma general de la ecuaci\u00f3n de calor en 2D es:</p> \\[ \\frac{\\partial u}{\\partial t} = c^2 \\left[\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\\right]  \\] <p>donde:</p> <ul> <li>\\(u(x, y, t)\\): temperatura en el punto \\((x, y)\\) en el tiempo \\(t\\)</li> <li>\\(c^2\\): coeficiente de difusi\u00f3n t\u00e9rmica</li> </ul>"},{"location":"matematica/formulacion/#dominio-y-condiciones","title":"Dominio y Condiciones","text":"<p>El problema se define en un dominio rectangular:</p> \\[ D = [0, a] \\times [0, b] \\subset \\mathbb{R}^2 \\] <p>en un intervalo temporal:</p> \\[ t \\in [0, T] \\]"},{"location":"matematica/formulacion/#condiciones-iniciales","title":"Condiciones Iniciales","text":"<p>La distribuci\u00f3n de temperatura en \\(t = 0\\) debe especificarse:</p> \\[ u(x, y, 0) = u_0(x, y) \\quad \\forall (x, y) \\in D \\] <p>Esta funci\u00f3n \\(u_0(x, y)\\) determina c\u00f3mo comienza el proceso de difusi\u00f3n t\u00e9rmica.</p>"},{"location":"matematica/formulacion/#condiciones-de-frontera","title":"Condiciones de Frontera","text":"<p>Las condiciones de frontera describen c\u00f3mo interact\u00faa la regi\u00f3n con su entorno. Se implementaron dos tipos principales:</p>"},{"location":"matematica/formulacion/#condiciones-de-dirichlet","title":"Condiciones de Dirichlet","text":"<p>Describen una temperatura constante en la frontera:</p> \\[ u(x, y, t) = g(x, y, t) \\quad \\text{en } \\partial D \\] <p>Interpretaci\u00f3n f\u00edsica: La frontera se mantiene a una temperatura conocida y constante.</p>"},{"location":"matematica/formulacion/#condiciones-de-neumann","title":"Condiciones de Neumann","text":"<p>Especifican el flujo de calor en la frontera:</p> \\[ \\frac{\\partial u}{\\partial n} = g(x, y, t) \\quad \\text{en } \\partial D \\] <p>Interpretaci\u00f3n f\u00edsica: Se prescribe el flujo t\u00e9rmico a trav\u00e9s de la frontera:</p> <ul> <li>Si g &gt; 0: el calor entra.</li> <li>Si g &lt; 0: el calor sale.</li> <li>Si g = 0: el sistema es aislado.</li> </ul>"},{"location":"matematica/metodologia/","title":"Metodolog\u00eda Num\u00e9rica","text":""},{"location":"matematica/metodologia/#esquema-de-euler-implicito","title":"Esquema de Euler Impl\u00edcito","text":"<p>Para resolver la ecuaci\u00f3n de calor num\u00e9ricamente, utilizamos el m\u00e9todo de diferencias finitas con el esquema de Euler Impl\u00edcito.</p>"},{"location":"matematica/metodologia/#discretizacion-del-dominio","title":"Discretizaci\u00f3n del Dominio","text":""},{"location":"matematica/metodologia/#malla-espacial","title":"Malla Espacial","text":"<p>Dividimos el dominio \\([0, a] \\times [0, b]\\) en una malla uniforme de \\(N \\times N\\) nodos interiores. Se definen los siguientes pasos espaciales:</p> \\[ \\begin{align} h_x = \\frac{a}{N+1} \\\\ h_y = \\frac{b}{N+1} \\end{align} \\]"},{"location":"matematica/metodologia/#malla-temporal","title":"Malla Temporal","text":"<p>El intervalo temporal \\([0, T]\\) se divide en \\(M\\) pasos donde \\(k = \\frac{T}{M}\\) es el paso temporal.</p>"},{"location":"matematica/metodologia/#aproximacion-por-diferencias-finitas","title":"Aproximaci\u00f3n por Diferencias Finitas","text":""},{"location":"matematica/metodologia/#derivadas-espaciales-diferencias-centrales","title":"Derivadas Espaciales (Diferencias Centrales)","text":"<p>Para las segundas derivadas espaciales usamos diferencias centrales de segundo orden:</p> \\[ \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{i,j} \\approx \\frac{u_{i-1,j} - 2u_{i,j} + u_{i+1,j}}{h_x^2} \\] \\[ \\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{i,j} \\approx \\frac{u_{i,j-1} - 2u_{i,j} + u_{i,j+1}}{h_y^2} \\] <p>Error de truncamiento: \\(\\mathcal{O}(h^2)\\)</p>"},{"location":"matematica/metodologia/#derivada-temporal-diferencias-hacia-adelante","title":"Derivada Temporal (Diferencias hacia adelante)","text":"<p>Se aproxima la derivada temporal haciendo diferencias hacia adelante:</p> \\[ \\frac{\\partial u}{\\partial t}\\bigg|_{i,j}^{n} \\approx \\frac{u_{i,j}^{n+1} - u_{i,j}^n}{k} \\]"},{"location":"matematica/metodologia/#esquema-numerico-completo","title":"Esquema Num\u00e9rico Completo","text":""},{"location":"matematica/metodologia/#ecuacion-discretizada","title":"Ecuaci\u00f3n Discretizada","text":"<p>Se sustituyen las aproximaciones anteriores en la ecuacion de calor:</p> \\[ \\frac{u_{i,j}^{n+1} - u_{i,j}^n}{k} = c^2 \\left[\\frac{u_{i-1,j}^{n+1} - 2u_{i,j}^{n+1} + u_{i+1,j}^{n+1}}{h_x^2} + \\frac{u_{i,j-1}^{n+1} - 2u_{i,j}^{n+1} + u_{i,j+1}^{n+1}}{h_y^2}\\right] \\] <p>De lo anterior, se puede definir:</p> \\[ \\mu_x = \\frac{c^2 k}{h_x^2}, \\quad \\mu_y = \\frac{c^2 k}{h_y^2} \\] <p>Reordenando queda:</p> \\[ (1 + 2\\mu_x + 2\\mu_y)u_{i,j}^{n+1} - \\mu_x(u_{i-1,j}^{n+1} + u_{i+1,j}^{n+1}) - \\mu_y(u_{i,j-1}^{n+1} + u_{i,j+1}^{n+1}) = u_{i,j}^n \\] <p>donde el lado derecho (RHS) contiene solo t\u00e9rminos conocidos en el tiempo \\(t_n\\).</p>"},{"location":"matematica/metodologia/#sistema-lineal","title":"Sistema Lineal","text":""},{"location":"matematica/metodologia/#estructura-matricial","title":"Estructura Matricial","text":"<p>El sistema completo obtenido anteriormente se puede escribir como:</p> \\[ A \\mathbf{u}^{n+1} = \\mathbf{b}^n \\] <p>donde:</p> <ul> <li>\\(A\\): matriz de coeficientes.</li> <li>\\(\\mathbf{u}^{n+1}\\): vector de inc\u00f3gnitas en el tiempo \\(t_{n+1}\\).</li> <li>\\(\\mathbf{b}^n\\): vector del lado derecho (conocido).</li> </ul>"},{"location":"matematica/metodologia/#ordenamiento-de-incognitas","title":"Ordenamiento de Inc\u00f3gnitas","text":"<p>Se ordenan las incognitas de la siguiente manera:</p> \\[ \\mathbf{u^{n+1}} = [u_{1,1}, u_{2,1}, \\ldots, u_{N_x,1}, u_{1,2}, u_{2,2}, \\ldots, u_{N_x,2}, \\ldots, u_{N_x,N_y}]^T \\] <p>Este ordenamiento resulta en una matriz \\(A\\) de dimensi\u00f3n \\((N \\times N) \\times (N \\times N)\\).</p>"},{"location":"matematica/metodologia/#estructura-de-la-matriz-a","title":"Estructura de la Matriz \\(A\\)","text":"<p>De lo obtenido anteriormente, podemos ver que para un punto \\((i,j)\\) dentro de la malla, su ecuacion tambien involucra a sus vecinos horizontales y verticales, donde podemos ver que sus coeficientes se ven de la siguiente manera:</p> <ul> <li>\\(u^{n+1}_{i,j}: 1 + 2\\mu_x + 2\\mu_y\\)</li> <li>\\({u}^{n+1}_{i\\pm1,j}:-\\mu_x\\)</li> <li>\\({u}^{n+1}_{i,j\\pm1}:-\\mu_x\\)</li> </ul> <p>Entonces, \\(A\\) es una matriz tridiagonal por bloques con la siguiente estructura:</p>"},{"location":"matematica/metodologia/#bloque-diagonal-b","title":"Bloque diagonal B","text":"<p>Corresponden a los nodos de una misma fila, donde su diagonal principal es \\(1 + 2\\mu_x + 2\\mu_y\\) y subdiagonal y superdiagonal es \\(-\\mu_x\\). Es decir: \\(B= tridiagonal(-\\mu_x, 1 + 2\\mu_x + 2\\mu_y, -\\mu_x)\\)</p>"},{"location":"matematica/metodologia/#bloques-fuera-de-la-diagonal","title":"Bloques fuera de la diagonal","text":"<p>Son los que conectan filas adyacentes, o sea \\(j\\) y \\(j\\pm1\\). Entonces cada nodo \\((i,j)\\) se conecta solo con nodos de la misma columna pero diferente fila. Por lo tanto, estos bloques estan compuestos por matrices diagonales con \\(-\\mu_y\\) en la diagonal, es decir, \\(C=-\\mu_y I\\)</p> <p>Entonces, la matriz A tiene la siguiente forma:</p> \\[ A= \\begin{bmatrix}     B &amp; C &amp; 0 &amp; \\ldots &amp; 0 \\\\ C &amp; B &amp; C &amp; \\ldots &amp; 0 \\\\ 0 &amp; C &amp; B &amp; \\ddots &amp; \\vdots \\\\ \\vdots &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp; C \\\\     0 &amp; \\ldots &amp; 0 &amp; C &amp; B     \\end{bmatrix}     \\] <p>Esta es una matriz dispersa que se puede almacenar y resolver eficientemente.</p>"}]}